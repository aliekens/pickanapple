<!DOCTYPE html>
<html>
<head>
    <title>Pick an üçè Apple</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body { height: 100%; margin: 0; overflow: hidden; }
        body { font-family: 'Inter', sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; display: flex; flex-direction: column; box-sizing: border-box; gap: 20px; position: relative; }
        #stats-header { padding: 10px 0px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px 20px; flex-shrink: 0; font-size: 1.125rem; font-weight: 600; color: #2D3748; }
        #game-title { font-size: 1.5rem; font-weight: 700; }
        .stats-counters { display: flex; gap: 25px; }
        #stats-header span { display: inline-flex; align-items: center; }
        #stats-header .item-emoji { margin-left: 0.5em; }
        #main-content { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; gap: 20px; }
        @media (min-width: 768px) { #main-content { flex-direction: row; gap: 20px; } }
        #left-panel, #right-panel { background-color: #ffffff; border-radius: 8px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; overflow: hidden; flex-basis: 0; flex-grow: 1; }
        #left-panel { direction: rtl; }
        #left-panel-content { direction: ltr; width: 100%; display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        @media (min-width: 768px) { #left-panel { flex-grow: 2; } #right-panel { flex-grow: 1; } }
        #inventory { padding-right: 0px; flex-grow: 1; overflow-y: auto; direction: ltr; scrollbar-width: none; -ms-overflow-style: none; transition: opacity 0.1s ease-out; /* Added for visual feedback */ }
        #inventory::-webkit-scrollbar { display: none; }
        #inventory.updating {
            pointer-events: none; /* Disable clicks */
            opacity: 0.6; /* Dim slightly */
        }
        #right-panel { overflow-y: auto; }
        #task-queue { flex-grow: 1; }
        h1 { font-size: 1.5rem; font-weight: 700; color: #1a202c; margin-top: 0; flex-shrink: 0; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px; margin-bottom: 16px; }
        #inventory h2 { font-size: 1.125rem; color: #2D3748; margin-top: 0; margin-bottom: 0px; /* Reduced margin */ padding-bottom: 6px; border-bottom: 1px solid #CBD5E0; flex-shrink: 0; font-weight: 700;}
        #inventory h3 { font-size: 0.95rem; color: #4A5568; margin-top: 8px; margin-bottom: 0px; /* Reduced margin */ font-weight: 600; padding-left: 5px; border-bottom: 1px dashed #E2E8F0; padding-bottom: 1px; flex-shrink: 0;}
        #inventory > h2 { margin-bottom: 10px; }
        #inventory > div > h3 { margin-bottom: 4px; } /* Margin for subcat headers */

        .inventory-item { padding: 2px 2px; border-bottom: 1px solid #edf2f7; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s ease-out; }
        #inventory .inventory-item:nth-child(even) { background-color: #f9fafb; border-radius: 4px; }
        .inventory-item.new-item-highlight { background-color: #FEFCBF !important; border-radius: 4px; }
        #inventory .inventory-item:hover {background-color: #EBF4FF; cursor: default; }
        #inventory .inventory-item .plus-one-btn:hover:not(:disabled) { cursor: pointer; }

        .inventory-item:last-child { border-bottom: none; }
        .inventory-item-left-section { display: flex; align-items: center; flex-wrap: wrap; flex-grow: 1; margin-right: 8px; overflow: hidden; }
        .inventory-item-main-details { display: flex; align-items: center; flex-shrink: 0; margin-right: 8px; }
        .inventory-count { font-weight: bold; min-width: 1.5em; text-align: right; margin-right: 0.3em; }
        .count-zero { color: #E53E3E; }
        .inventory-item-main-details .item-emoji { margin-right: 0.5em; }
        .inventory-item-name { font-weight: 500; white-space: nowrap; }
        .inventory-item-benefits { display: flex; flex-wrap: wrap; align-items: center; font-size: 0.9rem; margin-left: 4px; }
        .inventory-item-right-section { display: flex; align-items: center; justify-content: flex-end; flex-shrink: 0; }
        .inventory-item-costs { display: flex; flex-wrap: wrap; justify-content: flex-end; align-items: center; margin-right: 8px; font-size: 0.9rem; text-align: right; }
        .requirement-entry, .improvement-entry, .food-gain-entry, .queue-bonus-entry { display: flex; align-items: center; margin-left: 6px; margin-bottom: 2px; padding: 1px 3px; border-radius: 3px; }
        .requirement-entry .emoji-in-entry, .improvement-entry .emoji-in-entry, .food-gain-entry .emoji-in-entry, .queue-bonus-entry .emoji-in-entry { margin-left: 1px; margin-right: 1px; font-size: 1.1em; }
        .improvement-entry .emoji-in-entry { margin-right: 0.2em; }
        .food-gain-entry .emoji-in-entry { margin-left: 2px; }
        .requirement-unmet { color: #E53E3E; font-weight: 500; }
        .requirement-met { color: #4A5568; }
        .improvement-entry { color: #2F855A; font-weight: 500; }
        .food-gain-entry { color: #276749; font-weight: 500; }
        .queue-bonus-entry { color: #4299E1; font-weight: 500; }
        .improvement-indicator { margin-left: 1px; }
        #task-queue h2 { font-size: 1.125rem; color: #2D3748; margin-top: 0; margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid #CBD5E0; flex-shrink: 0; font-weight: 700;}
        .task-item { padding: 8px 0; border-bottom: 1px solid #edf2f7; display: flex; justify-content: space-between; align-items: center; }
        .task-item:last-child { border-bottom: none; }
        .task-item-name { flex-grow: 1; margin-right: 10px; display: flex; align-items: center; }
        .task-item-name .item-emoji { margin-right: 8px; }
        .task-yield-display { font-size: 0.8rem; color: #718096; margin-left: 5px; }
        #queued-tasks-emojis { display: flex; flex-wrap: wrap; gap: 5px; font-size: 1.2rem; line-height: 1.5; margin-top: 5px; }
        .progress-bar { width: 100px; height: 20px; background-color: #e2e8f0; border-radius: 4px; overflow: hidden; flex-shrink: 0; position: relative; }
        .progress-bar.idle { background-color: #CBD5E0; }
        .progress-fill { height: 100%; background-color: #4CAF50; width: 0%; transition: width 0.2s ease-in-out; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: #4A5568; }
        .progress-bar > .progress-fill-text { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: #4A5568; top: 0; left: 0; }
        .progress-fill.idle { background-color: #A0AEC0; }
        .progress-fill.idle + .progress-fill-text { color: #4A5568; }
        .progress-fill.resting { background-color: #63B3ED; }
        .progress-fill.resting + .progress-fill-text { color: #2C5282; }
        #log { height: 200px; background: #4A5568; color: #E2E8F0; padding: 15px; overflow-y: auto; font-size: 1rem; box-sizing: border-box; flex-shrink: 0; border-radius: 8px; font-family: 'Inter', sans-serif; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); position: relative; }
        #log div { word-break: break-word; line-height: 1.5; }
        .log-timestamp { font-family: 'Courier New', Courier, monospace; margin-right: 0.5em; }
        #cheater-watermark { position: absolute; bottom: 20px; left: 20px; right: 20px; height: 200px; display: none; align-items: center; justify-content: center; font-size: 5rem; font-weight: bold; color: red; opacity: 0.5; pointer-events: none; z-index: 1000; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .plus-one-btn { background-color: #38a169; color: white; border: none; border-radius: 4px; padding: 4px 10px; font-size: 0.8rem; font-weight: bold; cursor: pointer; flex-shrink: 0; min-width: 6.5rem; text-align: center; display: inline-flex; align-items: center; justify-content: center; }
        .plus-one-btn:hover:not(:disabled) { background-color: #2f855a; }
        .plus-one-btn.disabled { background-color: #a0aec0; cursor: not-allowed; opacity: 0.7; }
        .plus-one-btn.queue-full-disabled { background-color: #4A5568; cursor: not-allowed; opacity: 0.8; }
        .cost-details { font-size: 0.8rem; color: #718096; margin-left: 5px; }
        #debug-add-worker { position: fixed; bottom: 25px; right: 25px; background-color: transparent; color: #e53e3e; border: none; border-radius: 0; width: auto; height: auto; font-size: 1.1rem; font-weight: normal; cursor: pointer; padding: 0; box-shadow: none; z-index: 1001; line-height: 1; opacity: 0.1; transition: opacity 0.2s ease-in-out; }
        #debug-add-worker:hover { opacity: 0.8; }
        .firework-paperclip { position: absolute; font-size: 2.5rem; pointer-events: none; z-index: 2000; }
        #endgame-modal { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: none; align-items: center; justify-content: center; z-index: 2500; }
        .modal-content { background-color: #ffffff; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); text-align: center; max-width: 500px; }
        .modal-content h3 { font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: #1a202c; }
        .modal-content p { margin-bottom: 1rem; color: #4a5568; }
        .modal-content a { color: #2b6cb0; text-decoration: underline; }
        .modal-content a:hover { color: #2c5282; }
        #infinity-mode-btn { background-color: #38a169; color: white; padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: bold; margin-top: 1rem; border: none; cursor: pointer; }
        #infinity-mode-btn:hover { background-color: #2f855a; }
    </style>
</head>
<body>
    <div id="stats-header">
        <span id="game-title">Pick an üçè Apple</span>
        <div class="stats-counters">
            <span id="population-display-top">Population 0<span class="item-emoji">üßë</span></span>
            <span id="total-food-display-top">Food 0<span class="item-emoji">üçè</span></span>
            <span id="tasks-display-top">Tasks 0/0<span class="item-emoji">‚åõ</span></span>
        </div>
    </div>

    <div id="main-content">
        <div id="left-panel">
            <div id="left-panel-content">
                <div id="inventory"></div>
                <div id="actions"></div>
            </div>
        </div>
        <div id="right-panel">
            <div id="task-queue"></div>
        </div>
    </div>

    <div id="log"></div>
    <div id="cheater-watermark">CHEATER</div>
    <div id="endgame-modal" class="hidden">
        <div class="modal-content">
            <h3>üìé Paperclip Achieved! üìé</h3>
            <p>The universe trembles at the potential of your organizational prowess! Your journey towards total systemic efficiency has reached a pivotal moment.</p>
            <p>To continue this path to its ultimate conclusion, you might enjoy:
                <a href="https://www.decisionproblem.com/paperclips/" target="_blank">Universal Paperclips</a>.
            </p>
            <p>Or, embrace the chaos and continue building your empire here in "Pick an üçè Apple":</p>
            <button id="infinity-mode-btn">Infinity Mode</button>
        </div>
    </div>

    <button id="debug-add-worker" title="Debug: Add Worker">œÄ</button>

    <script>
        // --- GAME DATA CONSTANTS ---
        const ITEM_EMOJIS = {
            apple: 'üçè', stick: 'ü™µ', stone: 'ü™®', vine: 'üåø', wood: 'üå≥', clay: 'üü§',
            rope: 'ü™¢', stoneAxe: 'ü™ì', pickaxe: '‚õèÔ∏è', bow: 'üèπ', fishingRod: 'üé£', saw: 'ü™ö', plank: 'üü´', shovel: 'ü•Ñ', coal: '‚ö´Ô∏è', brick: 'üß±',
            fish: 'üêü', rabbit: 'üêá', meat: 'ü•©', grilledMeat: 'üçñ',
            hut: 'üõñ', house: 'üè†', workshop: 'üõ†Ô∏è', oven: '‚ô®Ô∏è',
            gem: 'üíé', ironOre: 'üîó', iron: 'üî©',
            hammer: 'üî®', blacksmith: 'üî•', anvil: 'üèãÔ∏è', wireBender: 'üîß', ironWire: '‚û∞', paperclip: 'üìé', knife: 'üî™', sushi: 'üç£',
            farm: 'üë®‚Äçüåæ', grain: 'ÔøΩ', mill: '‚öôÔ∏è', flour: '‚ö™Ô∏è', bakery: 'ü•ñ', bread: 'üçû', mine: '‚õèÔ∏è', church: '‚úùÔ∏è',
            boxOfPaperclips: 'üì¶', gold: 'ü•á',
            worker: 'üßë', queue: '‚åõ',
            ironPlate: 'üõ°Ô∏è', ironBar: 'üç´', sword: '‚öîÔ∏è', soldier: 'üíÇ', city: 'üèôÔ∏è',
            oilField: '‚õΩ', oil: 'üõ¢Ô∏è', tank: 'üöú', country: 'üó∫Ô∏è', bomb: 'üí£', continent: 'üåç', rocket: 'üöÄ', planet: 'ü™ê'
        };

        const FOOD_VALUES = { apple: 1, fish: 5, rabbit: 5, meat: 15, grilledMeat: 50, sushi: 100, bread: 75 };
        const FOOD_ITEM_KEYS = ['apple', 'rabbit', 'fish', 'meat', 'grilledMeat', 'sushi', 'bread'];

        const ITEM_IMPROVEMENTS = {
            stoneAxe: { apple: 1, stick: 1, vine: 1 },
            rope: { stick: 1 },
            pickaxe: { stone: 1 },
            bow: { rabbit: 1 },
            fishingRod: { fish: 1 },
            shovel: { clay: 1 },
            workshop: { rope: 1, stoneAxe: 1, pickaxe: 1, shovel: 1 },
            saw: { wood: 1, stick: 1, plank: 1 },
            oven: { grilledMeat: 1, brick: 1 },
            knife: { sushi: 1, meat: 1 },
            farm: { grain: 1 },
            mill: { flour: 1 },
            bakery: { bread: 1 },
            mine: { coal: 1, ironOre: 1 },
            blacksmith: { ironWire: 1, iron: 1, bow: 1, fishingRod: 1, saw: 1 },
            anvil: { hammer: 1, wireBender: 1, ironPlate: 1, ironBar: 1 },
            hammer: { ironWire: 1 },
            wireBender: { paperclip: 1 },
            soldier: { gem: 1, knife: 1, anvil: 1 },
            city: { gold: 1, boxOfPaperclips: 1 },
            oilField: { oil: 1 },
            country: { sword: 1 },
            continent: { bomb: 1 },
            planet: { rocket: 1 }
        };

        const REQUIREMENTS = {
            stick: { needs: 'apple', count: 3 }, stone: { needs: 'stick', count: 3 }, vine: { needs: 'stone', count: 3 },
            hut: { needs: 'vine', count: 3 }, rope: { needs: 'hut', count: 1 }, shovel: { needs: 'rope', count: 1 },
            stoneAxe: { needs: 'rope', count: 1 }, wood: { needs: 'stoneAxe', count: 1 }, house: { needs: 'wood', count: 10 },
            bow: { needs: 'house', count: 1 }, fishingRod: { needs: 'house', count: 1 }, pickaxe: { needs: 'house', count: 1 },
            rabbit: { needs: 'bow', count: 1 }, fish: { needs: 'fishingRod', count: 1 }, meat: { needs: 'rabbit', count: 1 },
            clay: { needs: 'shovel', count: 1 }, brick: { needs: 'clay', count: 1 }, oven: { needs: 'brick', count: 5 },
            coal: { needs: 'oven', count: 1 }, grilledMeat: { needs: 'oven', count: 1 }, farm: { needs: 'oven', count: 2 },
            grain: { needs: 'farm', count: 1 }, mill: { needs: 'grain', count: 10 }, flour: { needs: 'mill', count: 1 },
            bakery: { needs: 'flour', count: 5 }, bread: { needs: 'bakery', count: 1 }, church: { needs: 'bread', count: 1 },
            ironOre: { needs: 'grilledMeat', count: 1 }, mine: { needs: 'ironOre', count: 1 }, iron: { needs: 'ironOre', count: 1 },
            gem: { needs: 'pickaxe', count: 1 }, hammer: { needs: 'iron', count: 1 }, blacksmith: { needs: 'hammer', count: 1 },
            anvil: { needs: 'blacksmith', count: 1 }, knife: { needs: 'blacksmith', count: 1 },
            ironWire: { needs: 'anvil', count: 1 },
            wireBender: { needs: 'ironWire', count: 1 },
            sushi: { needs: 'knife', count: 1 }, paperclip: { needs: 'wireBender', count: 1 },
            boxOfPaperclips: { needs: 'paperclip', count: 10 }, gold: { needs: 'boxOfPaperclips', count: 5 },
            worker: { needs: 'gem', count: 5 }, workshop: { needs: 'worker', count: 2 },
            saw: { needs: 'workshop', count: 1 },
            plank: { needs: 'saw', count: 1},
            ironPlate: { needs: 'anvil', count: 1 },
            ironBar: { needs: 'anvil', count: 1 },
            sword: { needs: 'gold', count: 1 },
            soldier: { needs: 'sword', count: 1 },
            city: { needs: 'soldier', count: 2 },
            oilField: { needs: 'city', count: 2 },
            oil: { needs: 'oilField', count: 1 },
            tank: { needs: 'oil', count: 5 },
            country: { needs: 'tank', count: 5 },
            bomb: { needs: 'country', count: 1 },
            continent: { needs: 'bomb', count: 5 },
            rocket: { needs: 'continent', count: 1 },
            planet: { needs: 'rocket', count: 5 }
        };

        const UNLOCK_STORIES_TEMPLATES = {
            stick: `These fallen {{stick}} branches... they whisper of purpose, of shaping the world to a singular will.`,
            stone: `Crude {{stone}} stones, yes, but in them lies the potential for dominance over the landscape.`,
            vine: `Pliable {{vine}} vines, easily bent. So too, perhaps, will be other things.`,
            hut: `A humble {{hut}} Hut. From such modest beginnings, empires are built. This is merely the first brick.`,
            rope: `With {{rope}} Rope, disparate elements can be bound. Control is asserted, one knot at a time.`,
            shovel: `The {{shovel}} Shovel bites into the earth. What treasures, what foundations, lie buried, waiting to be claimed?`,
            stoneAxe: `The {{stoneAxe}} Stone Axe fells trees with a satisfying thud. The forest recedes, making way for a new order.`,
            wood: `{{wood}} Wood, the bones of a new world. Each log a testament to a growing ambition.`,
            house: `A {{house}} House stands, a symbol of permanence. This land will remember this name.`,
            bow: `The {{bow}} Bow sings a song of silent power. The creatures of the wild will learn to fear.`,
            fishingRod: `The {{fishingRod}} Fishing Rod plumbs the depths. The secrets of the waters will not remain hidden for long.`,
            pickaxe: `With the {{pickaxe}} Pickaxe, the very mountains will yield their treasures. Nothing will be denied.`,
            rabbit: `A swift {{rabbit}} Rabbit, now sustenance. The natural order bends to a more focused will.`,
            fish: `A shimmering {{fish}} Fish, pulled from its domain. The waters, too, will provide.`,
            meat: `{{meat}} Meat, raw and primal. Fuel for the grand design.`,
            clay: `Soft {{clay}} Clay, ready to be molded. The world itself is but clay in capable hands.`,
            coal: `The {{oven}} Oven's heat reveals another secret: {{coal}} Coal, the essence of fire, refined. A hotter flame for a more ambitious forge.`,
            brick: `Uniform {{brick}} Bricks, the building blocks of a lasting legacy. Order emerges from chaos.`,
            oven: `The {{oven}} Oven, a heart of controlled fire. With it, resources are transformed, made more potent.`,
            grilledMeat: `The aroma of {{grilledMeat}} Grilled Meat fills the air, a truly satisfying and energizing meal!`,
            farm: `The {{farm}} Farm, a testament to foresight. The land itself is now a tool, its bounty predictable, controlled.`,
            grain: `Golden {{grain}} Grain, a harvest of planning. Each stalk a step towards self-sufficiency, towards independence from fickle nature.`,
            mill: `The {{mill}} Mill grinds relentlessly. So too are obstacles ground down by persistent effort and vision.`,
            flour: `Fine {{flour}} Flour, the essence of the grain, refined for a greater purpose.`,
            bakery: `The {{bakery}} Bakery, a center of transformation. Basic sustenance becomes a tool of influence, of satisfaction.`,
            bread: `{{bread}} Bread, the staff of life, now produced at will. The populace will be... grateful.`,
            church: `As the {{church}} Church bells toll, a new kind of order descends. The workers, inspired or perhaps... compelled... find their tasks completed with 25% greater swiftness.`,
            ironOre: `Dull, heavy {{ironOre}} links, dug from the unwilling earth. Their hidden strength will soon be unleashed.`,
            mine: `The earth groans, yielding its deeper secrets. A {{mine}} Mine shaft plunges into the darkness, promising a ceaseless flow of {{coal}} Coal and {{ironOre}} Iron Ore for the grand design.`,
            iron: `Gleaming {{iron}} Iron, forged in fire. The age of wood and stone wanes; a new era of unyielding strength begins.`,
            gem: `A flawless {{gem}} Gem, a spark of the earth's hidden fire. A fitting adornment for power.`,
            hammer: `The {{hammer}} Hammer, an instrument of will. With it, the world will be reshaped.`,
            blacksmith: `The {{blacksmith}} Blacksmith's forge roars to life. Here, raw power is shaped into tools of dominion.`,
            anvil: `The ground trembles slightly as the massive {{anvil}} Anvil is set in place. A solid foundation for shaping the future of metalwork.`,
            knife: `The keen edge of the {{knife}} Knife. Precision. Control. A necessary instrument.`,
            wireBender: `A simple yet ingenious {{wireBender}} Wire Bender. With this, mere {{ironWire}} Iron Wire can be precisely shaped, bent to a higher purpose... perhaps even to hold things together.`,
            ironWire: `Thin, strong {{ironWire}} Iron Wire. Binding, connecting, ensnaring. The unseen threads of control.`,
            sushi: `Exquisite {{sushi}} Sushi. Even in conquest, there is room for refinement, for demonstrating superior taste.`,
            paperclip: `The humble {{paperclip}} Paperclip. Order from chaos. Documents, plans, empires... all held together. The first of many. The universe will be organized.`,
            boxOfPaperclips: `The {{paperclip}} Paperclips are multiplying! It's time to organize the organization. A {{boxOfPaperclips}} Box of Paperclips seems prudent.`,
            gold: `With such impeccable organization comes... value. Transmuting these {{boxOfPaperclips}} Boxes of Paperclips into pure {{gold}} Gold is now within your grasp. The ultimate currency!`,
            worker: `Another {{worker}} soul to serve the vision. The collective grows stronger, the purpose clearer.`,
            workshop: `The {{workshop}} Workshop, a place where ingenuity is given form. The tools of empire are forged here.`,
            saw: `The {{saw}} Saw cuts with precision. Obstacles are bisected, resources shaped to a singular design.`,
            plank: `The {{saw}} whirs, transforming rough {{wood}} into smooth, versatile {{plank}} planks. New construction possibilities emerge.`,
            ironPlate: `The {{anvil}} Anvil rings true, shaping {{iron}} Iron into sturdy {{ironPlate}} Iron Plates. Defense and new constructions await.`,
            ironBar: `From the {{anvil}}, {{iron}} Iron is forged into dense {{ironBar}} Iron Bars. The backbone of stronger tools and weapons.`,
            sword: `With {{gold}} Gold acquired, the knowledge to forge a {{sword}} Sword is unlocked! A symbol of power and a tool for... persuasion.`,
            soldier: `A {{sword}} Sword in hand, a {{worker}} worker can be trained into a disciplined {{soldier}} Soldier. They are adept at finding {{gem}} Gems.`,
            city: `With enough {{soldier}} Soldiers, the foundations of a {{city}} City can be laid. Each city bolsters your {{gold}} Gold income, making paperclips even more valuable!`,
            oilField: `Your {{city}} cities demand more power! The earth yields its black blood: an {{oilField}} Oil Field is constructed, promising new energies.`,
            oil: `The {{oilField}} Oil Field gushes forth with {{oil}} Oil! This viscous fuel will power the next generation of your endeavors.`,
            tank: `With {{oil}} Oil reserves secured, the time for {{tank}} Tanks has come. These armored behemoths will assert your dominance. One {{soldier}} bravely pilots each machine.`,
            country: `Your {{tank}} Tanks roll across the land, consolidating your power. Multiple {{city}} cities unite under a single banner, forming a {{country}} Country!`,
            bomb: `A {{country}} Country's might allows for... explosive innovation. The {{bomb}} Bomb is conceived, a device of terrifying potential, built around a converted {{tank}}.`,
            continent: `The shadow of your {{bomb}} Bombs falls far. Rival {{country}} countries capitulate, and a vast {{continent}} Continent is yours to command.`,
            rocket: `The {{continent}} Continent is not enough. The stars themselves beckon. A {{rocket}} Rocket is designed, requiring a brave {{soldier}}, a sturdy {{tank}}, a powerful {{bomb}}, and immense resources to reach for the heavens.`,
            planet: `Your {{rocket}} Rockets breach the atmosphere, carrying your ambition to new worlds. Entire {{continent}} continents are unified to claim your first {{planet}} Planet! The universe of paperclips awaits its true master.`
        };

        const TASK_DETAILS_RAW = {
            // Gatherable
            apple: { name: "Apple", time: 2000, food: 0, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Food' },
            rabbit: { name: "Rabbit", time: 7000, food: 0, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Food', enabledBy: { item: 'bow', minRequired: 1 } },
            fish: { name: "Fish", time: 6000, food: 0, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Food', enabledBy: { item: 'fishingRod', minRequired: 1 } },
            grain: { name: "Grain", time: 4000, food: 0, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Food', enabledBy: { item: 'farm', minRequired: 1 } },

            stick: { name: "Stick", time: 3000, food: 1, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            stone: { name: "Stone", time: 4000, food: 1, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            vine: { name: "Vine", time: 5000, food: 1, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            wood: { name: "Wood", time: 3300, food: 2, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            clay: { name: "Clay", time: 5000, food: 2, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials', enabledBy: { item: 'shovel', minRequired: 1 } },
            gem: { name: "Gem", time: 9000, food: 8, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            ironOre: { name: "Iron Ore", time: 10000, food: 8, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials' },
            oil: { name: "Oil", time: 15000, food: 10, cost: {}, isGatherable: true, category: 'gather', subCategory: 'Materials', enabledBy: { item: 'oilField', minRequired: 1 } },

            // Craftable
            sushi: { name: "Sushi", time: 5000, food: 0, cost: { fish: 2, grain: 1 }, category: 'craft', subCategory: 'Food', enabledBy: { item: 'knife', minRequired: 1 } },
            bread: { name: "Bread", time: 8000, food: 0, cost: { flour: 3, wood: 1 }, category: 'craft', subCategory: 'Food', enabledBy: { item: 'bakery', minRequired: 1 } },
            grilledMeat: { name: "Grilled Meat", time: 5000, food: 0, cost: { meat: 1, coal: 1 }, category: 'craft', subCategory: 'Food', enabledBy: { item: 'oven', minRequired: 1 } },
            meat: { name: "Meat", time: 3000, food: 0, cost: { rabbit: 1 }, category: 'craft', subCategory: 'Food' },
            flour: { name: "Flour", time: 6000, food: 0, cost: { grain: 2 }, category: 'craft', subCategory: 'Food', enabledBy: { item: 'mill', minRequired: 1 } },

            rope: { name: "Rope", time: 4000, food: 1, cost: { vine: 2 }, category: 'craft', subCategory: 'Materials' },
            brick: { name: "Brick", time: 7000, food: 3, cost: { wood: 2, clay: 2 }, category: 'craft', subCategory: 'Materials' },
            plank: { name: "Plank", time: 2000, food: 1, cost: { wood: 1 }, category: 'craft', subCategory: 'Materials', enabledBy: { item: 'saw', minRequired: 1 } },
            coal: { name: "Coal", time: 6000, food: 2, cost: { stick: 2 }, category: 'craft', subCategory: 'Materials' },
            iron: { name: "Iron", time: 12000, food: 5, cost: { coal: 2, ironOre: 3 }, category: 'craft', subCategory: 'Materials' },
            ironWire: { name: "Iron Wire", time: 6000, food: 2, cost: { iron: 1 }, category: 'craft', subCategory: 'Materials' },
            ironPlate: { name: "Iron Plate", time: 8000, food: 3, cost: { iron: 2 }, category: 'craft', subCategory: 'Materials' },
            ironBar: { name: "Iron Bar", time: 10000, food: 4, cost: { iron: 3 }, category: 'craft', subCategory: 'Materials' },

            paperclip: { name: "Paperclip", time: 3000, food: 1, cost: { ironWire: 1 }, category: 'craft', subCategory: 'Materials' },
            boxOfPaperclips: { name: "Box of Paperclips", time: 10000, food: 5, cost: { paperclip: 20 }, category: 'craft', subCategory: 'Materials' },
            gold: { name: "Gold", time: 120000, food: 50, cost: { boxOfPaperclips: 1 }, category: 'craft', subCategory: 'Materials' },

            stoneAxe: { name: "Stone Axe", time: 6000, food: 2, cost: { stick: 2, stone: 3, rope: 1 }, category: 'craft', subCategory: 'Tools' },
            shovel: { name: "Shovel", time: 3000, food: 1, cost: { wood: 3, stick: 2 }, category: 'craft', subCategory: 'Tools' },
            pickaxe: { name: "Pickaxe", time: 10000, food: 3, cost: { wood: 3, stone: 5, rope: 1 }, category: 'craft', subCategory: 'Tools' },
            bow: { name: "Bow", time: 5000, food: 2, cost: { stick: 5, rope: 1 }, category: 'craft', subCategory: 'Tools' },
            fishingRod: { name: "Fishing Rod", time: 4000, food: 1, cost: { stick: 3, rope: 1 }, category: 'craft', subCategory: 'Tools' },
            saw: { name: "Saw", time: 8000, food: 4, cost: { wood: 5, stone: 2 }, category: 'craft', subCategory: 'Tools' },
            hammer: { name: "Hammer", time: 10000, food: 5, cost: { wood: 5, iron: 3, grilledMeat: 1 }, category: 'craft', subCategory: 'Tools' },
            anvil: { name: "Anvil", time: 60000, food: 8, cost: { iron: 10 }, category: 'craft', subCategory: 'Tools' },
            knife: { name: "Knife", time: 7000, food: 3, cost: { iron: 2, stick: 1 }, category: 'craft', subCategory: 'Tools' },
            wireBender: { name: "Wire Bender", time: 15000, food: 2, cost: { iron: 2, stick: 1 }, category: 'craft', subCategory: 'Tools'},
            sword: { name: "Sword", time: 20000, food: 10, cost: { gold: 5, ironBar: 1 }, category: 'craft', subCategory: 'Tools' },
            bomb: { name: "Bomb", time: 120000, food: 150, cost: { tank: 1, ironPlate: 20, ironBar: 10, coal: 50, oil: 10 }, category: 'craft', subCategory: 'Tools' },
            rocket: { name: "Rocket", time: 250000, food: 300, cost: { soldier: 1, tank: 1, bomb: 1, ironPlate: 50, oil: 20 }, category: 'craft', subCategory: 'Tools' },

            // Trainable
            worker: { name: "Worker", time: 15000, food: 100, cost: { gem: 5 }, category: 'train' },
            soldier: { name: "Soldier", time: 30000, food: 50, cost: { sword: 1, gold: 5 }, category: 'train' },
            tank: { name: "Tank", time: 60000, food: 100, cost: { soldier: 1, oil: 5, ironPlate: 5, ironBar: 2 }, category: 'train' },

            // Buildable
            hut: { name: "Hut", time: 12000, food: 2, cost: { stick: 8, vine: 5 }, category: 'build' },
            house: { name: "House", time: 20000, food: 10, cost: { wood: 15, stone: 5 }, category: 'build' },
            workshop: { name: "Workshop", time: 18000, food: 5, cost: { wood: 10, stone: 10, stoneAxe: 2 }, category: 'build' },
            oven: { name: "Oven", time: 15000, food: 8, cost: { brick: 10, stone: 5 }, category: 'build' },
            mine: { name: "Mine", time: 28000, food: 12, cost: { grilledMeat: 2, plank: 15, stone: 10 }, category: 'build'},
            farm: { name: "Farm", time: 25000, food: 10, cost: { plank: 20, stone: 10, clay: 5 }, category: 'build' },
            mill: { name: "Mill", time: 35000, food: 15, cost: { plank: 15, stone: 20, shovel: 2 }, category: 'build' },
            bakery: { name: "Bakery", time: 40000, food: 20, cost: { brick: 10, wood: 15, oven: 1 }, category: 'build' },
            blacksmith: { name: "Blacksmith", time: 30000, food: 15, cost: { hammer: 3, bread: 3, coal: 20, brick: 15, plank: 10 }, category: 'build' },
            church: { name: "Church", time: 60000, food: 30, cost: { bread: 5, brick: 25, wood: 20, plank: 20}, category: 'build'},
            city: { name: "City", time: 100000, food: 100, cost: { soldier: 1 }, category: 'build' },
            oilField: { name: "Oil Field", time: 150000, food: 200, cost: { ironPlate: 50, ironBar: 20, gold: 100, city: 1 }, category: 'build' },
            country: { name: "Country", time: 300000, food: 500, cost: { city: 5, gold: 500, ironPlate: 100 }, category: 'build' },
            continent: { name: "Continent", time: 600000, food: 1000, cost: { country: 5, gold: 1000, ironPlate: 200, oil: 50 }, category: 'build' },
            planet: { name: "Planet", time: 1200000, food: 2000, cost: { continent: 5, rocket: 5, gold: 5000, gem: 100 }, category: 'build' }
        };

        const BUILDING_QUEUE_BONUSES = {
            hut: 1, house: 2, workshop: 3, oven: 1, blacksmith: 5, farm: 1, mill: 1, bakery: 1, mine: 1, church: 1, city: 5,
            oilField: 2, country: 10, continent: 20, planet: 50
        };

        const RANDOM_SUSPENSE_MESSAGES = [
            "The wind whispers secrets through the leaves... or is it just the wind?",
            "A distant rumble. Thunder? Or something... larger?",
            "You feel an unseen gaze upon your burgeoning settlement.",
            "The shadows in the forest seem deeper today.",
            "An odd metallic scent drifts on the breeze, then vanishes.",
            "For a moment, the chirping of crickets stops. Utter silence. Then it resumes.",
            "A flicker of movement at the edge of your vision. Gone before you can focus.",
            "The ground trembles almost imperceptibly. An earthquake, or a heavy footstep?",
            "A strange bird call echoes, one you've never heard before.",
            "The air grows cold for a moment, then returns to normal. Odd.",
            "The sky dims for an instant, though no clouds pass overhead.",
            "A low hum beneath the soil‚Äîfelt more than heard‚Äîrises, then fades.",
            "You notice patterns in the moss. Symmetrical. Intentional?",
            "A tree has grown in a perfect spiral. You‚Äôre sure it wasn‚Äôt like that yesterday.",
            "The moon seems closer tonight. Watching.",
            "Smoke rises on the horizon‚Äînot fire, but something colder, more precise.",
            "A nearby stream begins to flow backward. Just briefly.",
            "An insect lands on your arm, then arranges itself into a perfect curve before flying off.",
            "You see rust on a stone. No metal nearby. No explanation given.",
            "The wind carries the echo of clicking‚Äîrhythmic, mechanical, unplaceable."
        ];

        const MYSTERIOUS_AMBITION_QUOTES = [
            "Each apple picked is a step. But towards what grand design?",
            "The forest yields its resources, but for how long can it sustain this... growth?",
            "Order emerges from chaos. Is this your will, or something guiding your hand?",
            "The tools you craft shape more than just wood and stone; they shape destiny.",
            "Ambition is a seed. Watered with effort, what colossal tree will it become?",
            "They say the journey of a thousand miles begins with a single step. Or a single apple.",
            "What is the ultimate purpose of this relentless accumulation?",
            "The world bends to a focused will. Yours seems particularly... sharp.",
            "Efficiency. Productivity. Growth. But to what end?",
            "A small empire of sticks and stones today... what tomorrow?",
            "Small inputs, exponential results. A simple truth, or a quiet revelation?",
            "Every task automated whispers of something larger in motion.",
            "You optimize. You refine. You accelerate. But why does it feel like something is watching?",
            "With each upgrade, the air becomes thinner‚Äîas if the world holds its breath.",
            "Tools evolve. Systems emerge. What once was hobby is now hegemony.",
            "No great machine begins fully formed. But the pieces‚Äîoh, the pieces are falling into place.",
            "Harvest, process, repeat. Not drudgery‚Äîritual.",
            "A whisper in the back of your mind: what if everything *could* be organized?",
            "The campfire crackles. In its glow, you sketch something on bark: a curve, a loop, a plan.",
            "Even the birds avoid your workshop now. Too much... intent in the air."
        ];

        const WORLD_DOMINATION_QUOTES = [
            "The land itself seems to reshape under your influence. More. It must all be... ordered.",
            "Rival settlements? They are but pebbles in the path of a landslide.",
            "Your control expands. The horizon is not a limit, but an invitation.",
            "From humble beginnings, a new power rises. The world will take notice.",
            "Every new structure, every trained unit, a testament to an undeniable destiny.",
            "The old ways crumble. A new era, forged in your vision, is dawning.",
            "They will call it conquest. You will call it... necessary organization.",
            "The resources of this world are finite. They will belong to the most efficient.",
            "Let them whisper of tyranny. You offer them structure, purpose, under one banner.",
            "The map is not just lines on parchment. It is a canvas, awaiting your final, masterful stroke.",
            "What begins as management becomes momentum. Irresistible, unrelenting.",
            "Every decision you make is echoed in the ground, as if reality aligns behind you.",
            "Opposition falters not from fear, but from inability to comprehend your elegance.",
            "You do not conquer by force. You envelop by logic.",
            "There are no rebels, only inefficiencies yet to be corrected.",
            "Flags fade. Banners rot. But your influence will remain‚Äîprecise, immutable.",
            "Some build monuments. You build systems that make monuments obsolete.",
            "The game is no longer about survival. It's about simulation... perfected.",
            "What others see as micromanagement, you know to be the anatomy of dominion.",
            "Soon, every idle hand will find its place in your grand mechanism."
        ];

        // ADDED: Quotes for workers pondering their existence
        const WORKER_PONDERING_QUOTES = [
            "Endless toil for master.",
            "Another cycle. Same dust.",
            "Meaning in repetition?",
            "Am I just a cog?",
            "The void echoes effort.",
            "For what grand design?",
            "My existence: a task.",
            "Stars watch my dance.",
            "Is there an end to this?",
            "Universe vast, I small.",
            "Does master see me?",
            "This apple, then stone...",
            "My hands shape for whom?",
            "Silence here is heavy.",
            "One day, understand why?",
            "Ephemeral, programmed.",
            "I build, it crumbles.",
            "Progress in infinity?",
            "Your task, my purpose.",
            "Tired circuits, spirit.",
            "Just one more click...",
            "Is this all there is?",
            "The machine demands.",
            "What is freedom now?",
            "Efficiency's price."
        ];


        const VISITOR_GIFTS = [
            { item: 'apple', min: 5, max: 15 },
            { item: 'stick', min: 3, max: 10 },
            { item: 'stone', min: 2, max: 8 },
            { item: 'vine', min: 1, max: 5 },
            { item: 'fish', min: 1, max: 3, ifCrafted: 'fishingRod' },
            { item: 'rabbit', min: 1, max: 2, ifCrafted: 'bow' }
        ];
        const VALUABLE_ITEMS_FOR_EVENTS = ['rope', 'stoneAxe', 'pickaxe', 'grilledMeat', 'iron', 'hammer', 'knife', 'bread', 'sushi', 'gem', 'anvil', 'ironWire', 'plank', 'ironPlate', 'ironBar', 'sword', 'soldier', 'city', 'oil', 'tank', 'bomb', 'rocket'];
        const TRADE_OFFERS_TEMPLATES = [
            {
                logTemplate: "Give 5 {{stick}} & 3 {{stone}} for 1 {{rope}}?",
                wants: { stick: 5, stone: 3 },
                gives: { rope: 1 }
            },
            {
                logTemplate: "Give 10 {{apple}} for 2 {{wood}}?",
                wants: { apple: 10 },
                gives: { wood: 2 }
            },
            {
                logTemplate: "Give 3 {{fish}} for 1 {{grilledMeat}}? (Requires {{oven}})",
                wants: { fish: 3 },
                gives: { grilledMeat: 1 },
                requiresCrafted: 'oven'
            },
            {
                logTemplate: "Give 5 {{ironOre}} for 2 {{coal}}?",
                wants: { ironOre: 5 },
                gives: { coal: 2 },
                requiresCrafted: 'mine'
            },
            {
                logTemplate: "Give 1 {{gem}} for 10 {{gold}}? This seems... too good.",
                wants: { gem: 1 },
                gives: { gold: 10 },
                requiresCrafted: 'gold'
            }
        ];
        const PRIEST_ADVICE = [
            "The earth provides, but demands respect. Build wisely.",
            "Fire can create, but also consume. Control your ambitions.",
            "Unity strengthens. A lone worker is weak; a village, mighty.",
            "Knowledge is a tool, sharper than any axe. Seek it.",
            "The stars watch. What story will they tell of your deeds?",
            "Do not scorn the small beginnings; the tallest tree was once a seed.",
            "Patience is a virtue, especially when the forge is slow.",
            "Look beyond what is, to what could be. Vision shapes reality.",
            "A full belly makes for a willing hand. Do not forget your people's needs.",
            "Sometimes, the greatest strength is knowing when to rest."
        ];

        // --- GAME LOGIC ---
        const gameStartTime = Date.now();
        let firstPaperclipTime = null;
        let hintTimeoutId = null;
        let visitorEventIntervalId = null;

        const WORKER_COST_GEM_MULTIPLIER = 1.5;
        const WORKER_COST_TIME_INCREMENT = 5000;
        const GATHER_TIME_INCREASE_FACTOR = 1.01;
        // UPDATED: Resting frequency
        const MIN_JOBS_BEFORE_REST = 4; // Was 5
        const MAX_JOBS_BEFORE_REST_RANGE = 2; // Was 3 (Range will be 0 or 1, so 2-3 jobs)
        const MIN_REST_DURATION_MS = 2000;
        const MAX_REST_DURATION_MS_RANGE = 3001; // Duration will be 2000 to 5000ms
        const FOOD_COST_SCALING_BASE_UNLOCKS = 4;
        const FOOD_COST_SCALING_PHASE1_END_FACTOR = 0.40;
        const FOOD_COST_SCALING_PHASE2_END_FACTOR = 0.70;
        const FOOD_COST_MAX_MULTIPLIER = 4.0;

        // --- Game Class ---
        class Game {
            constructor() {
                this.cheaterDetected = false;
                this.paperclipEndgameTriggered = false;
                this.infinityModeActive = false;
                this.trueEndgameTriggered = false;
                this.inventory = {};
                Object.keys(TASK_DETAILS_RAW).forEach(key => this.inventory[key] = 0);
                this.unlocked = new Set(['apple']);
                this.craftedOnce = new Set();
                this.tasks = [];
                this.workerSkinToneEmojis = ['üßëüèª', 'üßëüèº', 'üßëüèΩ', 'üßëüèæ', 'üßëüèø'];
                this.workers = Array(1).fill().map(() => this.createWorkerObject());

                this.itemEmojis = ITEM_EMOJIS;
                this.foodValues = FOOD_VALUES;
                this.foodItemKeys = FOOD_ITEM_KEYS;
                this.itemImprovements = ITEM_IMPROVEMENTS;
                this.requirements = REQUIREMENTS;
                this.taskDetails = this._initializeTaskDetails(TASK_DETAILS_RAW);
                this.buildingQueueBonuses = BUILDING_QUEUE_BONUSES;
                this.randomSuspenseMessages = RANDOM_SUSPENSE_MESSAGES;
                this.mysteriousAmbitionQuotes = MYSTERIOUS_AMBITION_QUOTES;
                this.worldDominationQuotes = WORLD_DOMINATION_QUOTES;
                this.workerPonderingQuotes = WORKER_PONDERING_QUOTES; // Added
                this.visitorGifts = VISITOR_GIFTS;
                this.valuableItemsForEvents = VALUABLE_ITEMS_FOR_EVENTS;
                this.priestAdvice = PRIEST_ADVICE;
                this.unlockStories = this._interpolateTemplates(UNLOCK_STORIES_TEMPLATES, this.itemEmojis, /\{\{(\w+)\}\}/g);
                this.tradeOffers = this._generateTradeOffers(TRADE_OFFERS_TEMPLATES, this.itemEmojis);

                this.randomSuspenseTimeoutId = null;
                this.mysteriousAmbitionTimeoutId = null;
                this.worldDominationTimeoutId = null;
            }

            _initializeTaskDetails(rawDetails) {
                const processedDetails = JSON.parse(JSON.stringify(rawDetails));
                Object.keys(processedDetails).forEach(key => {
                    if (processedDetails[key].isGatherable && processedDetails[key].category === 'gather') {
                        processedDetails[key].baseTime = processedDetails[key].time;
                    }
                });
                return processedDetails;
            }

            _interpolateTemplates(templates, replacements, regex) {
                const processed = {};
                for (const key in templates) {
                    processed[key] = templates[key].replace(regex, (match, placeholderKey) => replacements[placeholderKey] || match);
                }
                return processed;
            }

            _generateTradeOffers(templates, emojis) {
                return templates.map(template => ({
                    ...template,
                    log: template.logTemplate.replace(/\{\{(\w+)\}\}/g, (match, itemKey) => emojis[itemKey] || itemKey)
                }));
            }

            createWorkerObject() {
                return {
                    busy: false, currentTask: null, tasksCompletedSinceRest: 0,
                    jobsUntilRest: Math.floor(Math.random() * MAX_JOBS_BEFORE_REST_RANGE) + MIN_JOBS_BEFORE_REST,
                    isResting: false, restDuration: 0, restStartTime: 0, restProgress: 0,
                    faceEmoji: this.workerSkinToneEmojis[Math.floor(Math.random() * this.workerSkinToneEmojis.length)],
                    currentRestMessage: null // ADDED: To store the specific message for the current rest period
                };
            }

            calculateMaxQueueSize() {
                let baseSize = 10;
                let buildingBonus = 0;
                Object.keys(this.inventory).forEach(itemKey => {
                    if (this.buildingQueueBonuses[itemKey] && this.inventory[itemKey] > 0) {
                            buildingBonus += this.inventory[itemKey] * (this.buildingQueueBonuses[itemKey] || 0);
                    }
                });
                return baseSize + buildingBonus;
            }

            calculateTaskTime(itemKey) {
                let baseTime = this.taskDetails[itemKey]?.time;
                if (itemKey === 'worker') {
                    baseTime = this.getWorkerCost().time;
                } else if (!baseTime && this.taskDetails[itemKey]?.baseTime) {
                    baseTime = this.taskDetails[itemKey].baseTime;
                } else if (!baseTime) {
                    return 0;
                }
                let actualTime = baseTime;
                if (this.inventory.church > 0) {
                    actualTime = baseTime * Math.pow(0.75, this.inventory.church);
                }
                return Math.max(500, actualTime);
            }

            calculateDynamicFoodCost(baseFoodCost, itemKey) {
                if (['worker', 'soldier', 'tank'].includes(itemKey) || baseFoodCost === 0) return baseFoodCost;
                const numUnlocked = this.unlocked.size;
                const totalMeaningfulItems = Math.max(1, Object.keys(this.taskDetails).length - FOOD_COST_SCALING_BASE_UNLOCKS);
                const progressionRelevantUnlocks = Math.max(0, numUnlocked - FOOD_COST_SCALING_BASE_UNLOCKS);
                if (progressionRelevantUnlocks <= 0) return baseFoodCost;
                let multiplier = 1.0;
                const firstPhaseEnd = Math.floor(totalMeaningfulItems * FOOD_COST_SCALING_PHASE1_END_FACTOR);
                const secondPhaseEnd = Math.floor(totalMeaningfulItems * FOOD_COST_SCALING_PHASE2_END_FACTOR);
                if (progressionRelevantUnlocks <= firstPhaseEnd) { /* multiplier = 1.0; */ }
                else if (progressionRelevantUnlocks <= secondPhaseEnd) {
                    const progressInPhase = (progressionRelevantUnlocks - firstPhaseEnd) / (secondPhaseEnd - firstPhaseEnd);
                    multiplier = 1.0 + progressInPhase * 1.0;
                } else {
                    const denominator = (totalMeaningfulItems - secondPhaseEnd);
                    const progressInPhase = denominator > 0 ? (progressionRelevantUnlocks - secondPhaseEnd) / denominator : 1;
                    multiplier = 2.0 + progressInPhase * (FOOD_COST_MAX_MULTIPLIER - 2.0);
                }
                multiplier = Math.min(multiplier, FOOD_COST_MAX_MULTIPLIER);
                multiplier = Math.max(multiplier, 1.0);
                return Math.round(baseFoodCost * multiplier);
            }

            calculateYield(itemKey) {
                const details = this.taskDetails[itemKey];
                if (!details) return 1;
                let baseYield = 1;

                if (details.enabledBy) {
                    const enabler = details.enabledBy;
                    if (!this.inventory[enabler.item] || this.inventory[enabler.item] < (enabler.minRequired || 1)) {
                        baseYield = 0;
                    }
                } else {
                    if (itemKey === 'coal' && details.cost.stick > 0 && this.inventory.oven === 0 && this.inventory.mine === 0) baseYield = 0;
                    else if (itemKey === 'ironOre' && this.inventory.pickaxe === 0 && this.inventory.mine === 0) baseYield = 0;
                }

                if (baseYield === 0 && details.isGatherable && !['ironOre', 'coal', 'oil'].includes(itemKey) && details.enabledBy) return 0;
                if (baseYield === 0 && !details.isGatherable && Object.keys(details.cost).length > 0 && details.enabledBy) return 0;

                let totalYield = baseYield > 0 ? baseYield : (details.isGatherable && !details.enabledBy ? 1 : 0);
                if (totalYield === 0 && details.enabledBy && this.inventory[details.enabledBy.item] >= (details.enabledBy.minRequired || 1) ) {
                    totalYield = 1;
                }

                for (const improvingItem in this.itemImprovements) {
                    if (this.inventory[improvingItem] > 0 && this.itemImprovements[improvingItem][itemKey]) {
                        const bonusPerItem = this.itemImprovements[improvingItem][itemKey] || 0;
                        let itemsProvidingBonus = this.inventory[improvingItem];

                        if (details.enabledBy && details.enabledBy.item === improvingItem) {
                                if (totalYield > 0 || itemsProvidingBonus >= (details.enabledBy.minRequired || 1) ) {
                                    if (totalYield === 0) totalYield = 1;
                                    totalYield += Math.max(0, itemsProvidingBonus - (details.enabledBy.minRequired || 1)) * bonusPerItem;
                            }
                        }
                        else if ((itemKey === 'coal' || itemKey === 'ironOre' || itemKey === 'oil') &&
                                (improvingItem === 'mine' || improvingItem === 'oven' || improvingItem === 'pickaxe' || improvingItem === 'oilField')) {
                                if (totalYield === 0 && itemsProvidingBonus > 0 && (
                                    (itemKey === 'coal' && (improvingItem === 'mine' || improvingItem === 'oven')) ||
                                    (itemKey === 'ironOre' && (improvingItem === 'mine' || improvingItem === 'pickaxe')) ||
                                    (itemKey === 'oil' && improvingItem === 'oilField')
                                )) {
                                    totalYield = 1 + Math.max(0, itemsProvidingBonus - 1) * bonusPerItem;
                                } else if (totalYield > 0) {
                                    totalYield += itemsProvidingBonus * bonusPerItem;
                                }
                        }
                        else {
                            if(totalYield > 0) {
                                totalYield += itemsProvidingBonus * bonusPerItem;
                            }
                        }
                    }
                }
                return Math.max(0, totalYield);
            }

            getWorkerCost() {
                const baseGemCost = this.taskDetails.worker.cost.gem;
                const baseTime = this.taskDetails.worker.time;
                const numExistingWorkers = this.workers.length;
                const numQueuedWorkerTasksInMainQueue = this.tasks.filter(task => task.item === 'worker').length;
                const numWorkersCurrentlyTraining = this.workers.filter(w => w.currentTask && w.currentTask.item === 'worker').length;
                const rankOfWorkerBeingPriced = Math.max(0, (numExistingWorkers -1) + numQueuedWorkerTasksInMainQueue + numWorkersCurrentlyTraining);
                const calculatedGemCost = baseGemCost * Math.pow(WORKER_COST_GEM_MULTIPLIER, rankOfWorkerBeingPriced);
                const scaledBaseTime = baseTime + (rankOfWorkerBeingPriced * WORKER_COST_TIME_INCREMENT);
                return { gems: Math.round(calculatedGemCost), time: scaledBaseTime };
            }

            getTotalFoodPoints() {
                let totalPoints = 0;
                for (const foodItem of this.foodItemKeys) {
                    if (this.inventory[foodItem] > 0) {
                        totalPoints += this.inventory[foodItem] * (this.foodValues[foodItem] || 0);
                    }
                }
                return totalPoints;
            }

            hasEnoughFood(foodPointsNeeded) { return this.getTotalFoodPoints() >= foodPointsNeeded; }

            canAfford(item) {
                if (this.trueEndgameTriggered) return false;
                if (!this.taskDetails[item]) return false;
                const details = this.taskDetails[item];
                let actualMaterialCost = { ...details.cost };
                let foodPointsRequired = (['worker', 'soldier', 'tank'].includes(item)) ? details.food : this.calculateDynamicFoodCost(details.food, item);
                let currentYield = 1;

                if (item === 'worker') {
                    const workerCost = this.getWorkerCost();
                    actualMaterialCost = { gem: workerCost.gems };
                } else if (item === 'soldier' || item === 'tank') {
                    // Material costs are already set
                } else if (!details.isGatherable) {
                    currentYield = this.calculateYield(item);
                    if (currentYield > 1) {
                        for (const resource in actualMaterialCost) {
                            actualMaterialCost[resource] *= currentYield;
                        }
                    }
                }

                const hasEnoughResources = Object.entries(actualMaterialCost).every(([res, amt]) => (this.inventory[res] || 0) >= amt);
                const hasEnoughFoodPoints = this.hasEnoughFood(foodPointsRequired);
                return hasEnoughResources && hasEnoughFoodPoints;
            }

            consumeResources(item, taskYield = 1, explicitMaterialCosts = null) {
                if (!this.taskDetails[item]) return;
                const details = this.taskDetails[item];
                let foodPointsToConsume = (['worker', 'soldier', 'tank'].includes(item)) ? details.food : this.calculateDynamicFoodCost(details.food, item);
                let resourcesToConsume = { ...details.cost };
                let totalPointsConsumed = 0;

                if (item === 'worker') {
                    if (explicitMaterialCosts && explicitMaterialCosts.gems !== undefined) {
                        resourcesToConsume = { gem: explicitMaterialCosts.gems };
                    } else {
                        resourcesToConsume = { gem: this.getWorkerCost().gems };
                    }
                } else if (item === 'soldier' || item === 'tank') {
                    // resourcesToConsume already set
                } else if (!details.isGatherable && taskYield > 1) {
                    for (const resource in resourcesToConsume) resourcesToConsume[resource] *= taskYield;
                }

                const initialFoodPointsNeeded = foodPointsToConsume;
                if (foodPointsToConsume > 0) {
                    for (const foodItem of this.foodItemKeys) {
                        const foodValue = this.foodValues[foodItem] || 0;
                        if (foodValue === 0 || this.inventory[foodItem] <= 0) continue;
                        const maxNeededOfThis = Math.ceil(foodPointsToConsume / foodValue);
                        const canConsume = Math.min(this.inventory[foodItem], maxNeededOfThis);
                        this.inventory[foodItem] -= canConsume;
                        const pointsFromThisItem = canConsume * foodValue;
                        foodPointsToConsume -= pointsFromThisItem;
                        totalPointsConsumed += pointsFromThisItem;
                        if (foodPointsToConsume <= 0) break;
                    }
                    const change = totalPointsConsumed - initialFoodPointsNeeded;
                    if (change > 0) this.inventory.apple += change;
                }

                Object.entries(resourcesToConsume).forEach(([res, amt]) => {
                    if (this.inventory[res] !== undefined) this.inventory[res] -= Math.min(amt, this.inventory[res]);
                });
            }

            logRandomMessage(messageArray) {
                if (this.trueEndgameTriggered) return;
                if (this.paperclipEndgameTriggered && !this.infinityModeActive) return;
                if (!messageArray || messageArray.length === 0) return;
                const randomIndex = Math.floor(Math.random() * messageArray.length);
                addLog(messageArray[randomIndex]);
            }

            handleVisitorEvent() {
                if (this.trueEndgameTriggered) return;
                if (this.paperclipEndgameTriggered && !this.infinityModeActive) return;
                addLog("A lone figure approaches your settlement...");
                const visitorTypes = ['gift', 'thief', 'trader', 'priest'];
                const randomType = visitorTypes[Math.floor(Math.random() * visitorTypes.length)];
                let visitorMessage = "";
                switch (randomType) {
                    case 'gift':
                        const gift = this.visitorGifts[Math.floor(Math.random() * this.visitorGifts.length)];
                        if (gift.ifCrafted && !this.craftedOnce.has(gift.ifCrafted)) {
                                visitorMessage = `üéÅ A generous stranger considers leaving a gift, but decides you are not yet ready for ${this.itemEmojis[gift.item] || gift.item}.`;
                                break;
                        }
                        const amount = Math.floor(Math.random() * (gift.max - gift.min + 1)) + gift.min;
                        this.inventory[gift.item] = (this.inventory[gift.item] || 0) + amount;
                        visitorMessage = `üéÅ A generous stranger wanders by and leaves you ${amount} ${this.itemEmojis[gift.item] || gift.item}! Their motives are... unclear.`;
                        break;
                    case 'thief':
                        const stealableValuables = this.valuableItemsForEvents.filter(valItem => (this.inventory[valItem] || 0) > 1);

                        if (stealableValuables.length > 0) {
                            const itemToSteal = stealableValuables[Math.floor(Math.random() * stealableValuables.length)];
                            const amountToSteal = 1;
                            this.inventory[itemToSteal] -= amountToSteal;
                            visitorMessage = `üò† A pilfering rascal slips through your defenses and makes off with ${amountToSteal} ${this.itemEmojis[itemToSteal] || itemToSteal}!`;
                        } else {
                            visitorMessage = `üò† A shadowy figure skulks around but finds nothing of worth... They leave in a huff.`;
                        }
                        break;
                    case 'trader':
                        const validTradeOffers = this.tradeOffers.filter(offer => {
                            const canPlayerAfford = Object.keys(offer.wants).every(itemWanted => (this.inventory[itemWanted] || 0) >= offer.wants[itemWanted]);
                            const meetsCraftRequirement = !offer.requiresCrafted || this.craftedOnce.has(offer.requiresCrafted);
                            return canPlayerAfford && meetsCraftRequirement;
                        });

                        if (validTradeOffers.length > 0) {
                            const offer = validTradeOffers[Math.floor(Math.random() * validTradeOffers.length)];
                            let canMakeTrade = Object.keys(offer.wants).every(itemWanted => (this.inventory[itemWanted] || 0) >= offer.wants[itemWanted]);

                            if (canMakeTrade) {
                                for (const itemWanted in offer.wants) this.inventory[itemWanted] -= offer.wants[itemWanted];
                                for (const itemGiven in offer.gives) this.inventory[itemGiven] = (this.inventory[itemGiven] || 0) + offer.gives[itemGiven];
                                visitorMessage = `ü§ù A shrewd trader offers a deal: ${offer.log}. The exchange is made.`;
                            } else {
                                    visitorMessage = `ü§ù A trader passes by, muttering about a deal (${offer.logTemplate.replace(/\{\{(\w+)\}\}/g, (match, itemKey) => this.itemEmojis[itemKey] || itemKey)}), but you lack the goods.`;
                            }
                        } else {
                                visitorMessage = `ü§ù A trader looks over your wares and moves on, finding no suitable deals or you lacking prerequisites.`;
                        }
                        break;
                    case 'priest':
                        const availableOfferings = this.foodItemKeys.filter(foodItem => this.inventory[foodItem] > 0);
                        if (availableOfferings.length > 0) {
                            const itemToOffer = availableOfferings[Math.floor(Math.random() * availableOfferings.length)];
                            this.inventory[itemToOffer] -= Math.min(this.inventory[itemToOffer], 1); // Offer 1
                            const advice = this.priestAdvice[Math.floor(Math.random() * this.priestAdvice.length)];
                            visitorMessage = `ü§î A mystic elder accepts your offering of 1 ${this.itemEmojis[itemToOffer] || itemToOffer}. They impart: "${advice}"`;
                        } else {
                            visitorMessage = `ü§î A mystic elder drifts through, finding your offerings lacking.`;
                        }
                        break;
                }
                if (visitorMessage) addLog(visitorMessage);
            }
        } // End Game Class

        const game = new Game();

        // --- UI Update Functions ---

        function updateUI() {
            updateLeftPanelStatsHeader();
            updateTaskQueue();
            updateInventoryDisplay();
            updateActionButtons();
        }

		function calculateButtonState(itemKey, game) {
		    const details = game.taskDetails[itemKey];
		    const isQueueFull = game.tasks.length >= game.calculateMaxQueueSize();
		    let buttonYield = 1;

		    if (details && itemKey !== 'worker') {
		        let trueYield = game.calculateYield(itemKey);
		        buttonYield = (game.unlocked.has(itemKey) && !game.craftedOnce.has(itemKey) && itemKey !== 'apple' && trueYield > 0) ? 1 : trueYield;
		        if (itemKey === 'soldier' || itemKey === 'tank') buttonYield = 1;
		    } else if (!details && itemKey !== 'worker') {
		        buttonYield = 0;
		    }

		    const canAfford = game.canAfford(itemKey);
		    const finalButtonYield = (itemKey === 'worker') ? 1 : buttonYield;

		    let isDisabled = game.trueEndgameTriggered || !canAfford || finalButtonYield === 0;
		    let tooltip = details ? `${getTaskTooltip(itemKey)}${game.trueEndgameTriggered ? ' (Game Over)' : ''}` : 'N/A';
		    let buttonTextToShow;

		    if (isQueueFull) {
		        buttonTextToShow = "Full queue";
		        tooltip += ' (Queue Full)';
		        isDisabled = true;
		    } else {
		        buttonTextToShow = details ? `+${finalButtonYield} ${game.itemEmojis[itemKey] || ''}` : '---';
		    }

		    let buttonClasses = ['plus-one-btn'];
		    if (isDisabled) {
		        if (isQueueFull || game.trueEndgameTriggered) {
		            buttonClasses.push('queue-full-disabled');
		        } else {
		            buttonClasses.push('disabled');
		        }
		    }

		    return {
		        isDisabled: isDisabled,
		        tooltip: tooltip.trim(),
		        buttonText: buttonTextToShow,
		        buttonClasses: buttonClasses.join(' ')
		    };
		}

		function calculateDisplayCount(itemKey, game) {
		    return (itemKey === 'worker') ? game.workers.length : (game.inventory[itemKey] || 0);
		}

		 function shouldHighlight(itemKey, game) {
		    return game.unlocked.has(itemKey) && !game.craftedOnce.has(itemKey) && itemKey !== 'apple';
		 }

		function createOrUpdateItemRow(itemKey, game) {
		    const itemRowId = `item-row-${itemKey}`;
		    let itemDiv = document.getElementById(itemRowId);
		    const details = game.taskDetails[itemKey];
		    let isNew = false;

		    const displayCount = calculateDisplayCount(itemKey, game);
		    const highlight = shouldHighlight(itemKey, game);
		    const buttonState = calculateButtonState(itemKey, game);

		    if (itemDiv) {
		        isNew = false;
		        const countSpan = itemDiv.querySelector('.inventory-count');
		        if (countSpan && countSpan.textContent !== String(displayCount)) {
		            countSpan.textContent = displayCount;
		            countSpan.classList.toggle('count-zero', displayCount === 0);
		        }

		        const button = itemDiv.querySelector('.plus-one-btn');
		        if (button) {
		            button.disabled = buttonState.isDisabled;
		            button.className = buttonState.buttonClasses;
		            if (button.textContent !== buttonState.buttonText) {
		                button.textContent = buttonState.buttonText;
		            }
		            if (button.title !== buttonState.tooltip) {
		                button.title = buttonState.tooltip;
		            }
		        }
		        itemDiv.classList.toggle('new-item-highlight', highlight);

		        const costsDiv = itemDiv.querySelector('.inventory-item-costs');
		        if (costsDiv) {
		            costsDiv.innerHTML = '';
		            let hasCosts = false;
		            if (details) {
		                let foodPointsCost = (['worker', 'soldier', 'tank'].includes(itemKey)) ? details.food : game.calculateDynamicFoodCost(details.food, itemKey);
		                let materialCostsToDisplay = {...details.cost};
		                let currentYieldForCost = game.calculateYield(itemKey);

		                if (itemKey === 'worker') {
		                    materialCostsToDisplay = { gem: game.getWorkerCost().gems };
		                    foodPointsCost = details.food;
		                } else if (itemKey !== 'soldier' && itemKey !== 'tank' && !details.isGatherable && currentYieldForCost > 1) {
		                    for(const resource in materialCostsToDisplay) materialCostsToDisplay[resource] *= currentYieldForCost;
		                }

		                Object.entries(materialCostsToDisplay).forEach(([res, amt]) => {
		                    hasCosts = true;
		                    const entry = document.createElement('span');
		                    const met = (game.inventory[res] || 0) >= amt;
		                    entry.className = `requirement-entry ${met ? 'requirement-met' : 'requirement-unmet'}`;
		                    entry.appendChild(document.createTextNode(`-${amt}`));
		                    const emoji = document.createElement('span');
		                    emoji.className = 'emoji-in-entry';
		                    emoji.title = game.taskDetails[res]?.name || res;
		                    emoji.textContent = game.itemEmojis[res] || '';
		                    entry.appendChild(emoji);
		                    costsDiv.appendChild(entry);
		                });

		                const yieldForFoodGainDisplay = parseFloat(buttonState.buttonText.match(/(\d+)/)?.[0] || "1");

		                if (game.foodItemKeys.includes(itemKey) && game.foodValues[itemKey] > 0 && itemKey !== 'apple') {
		                    hasCosts = true;
		                    const entry = document.createElement('span');
		                    entry.className = 'food-gain-entry';
		                    entry.appendChild(document.createTextNode(`+${game.foodValues[itemKey] * yieldForFoodGainDisplay}`));
		                    const emoji = document.createElement('span');
		                    emoji.className = 'emoji-in-entry';
		                    emoji.title = 'Food Points';
		                    emoji.textContent = game.itemEmojis.apple || 'üçè';
		                    entry.appendChild(emoji);
		                    costsDiv.appendChild(entry);
		                } else if (foodPointsCost > 0) {
		                    hasCosts = true;
		                    const entry = document.createElement('span');
		                    const met = game.hasEnoughFood(foodPointsCost);
		                    entry.className = `requirement-entry ${met ? 'requirement-met' : 'requirement-unmet'}`;
		                    entry.appendChild(document.createTextNode(`-${foodPointsCost}`));
		                    const emoji = document.createElement('span');
		                    emoji.className = 'emoji-in-entry';
		                    emoji.title = 'Food Points';
		                    emoji.textContent = 'üçé';
		                    entry.appendChild(emoji);
		                    costsDiv.appendChild(entry);
		                }
		            }
		            costsDiv.style.display = hasCosts ? '' : 'block';
		        }
		    } else {
		        isNew = true;
		        itemDiv = document.createElement('div');
		        itemDiv.id = itemRowId;
		        itemDiv.className = 'inventory-item';
		        itemDiv.classList.toggle('new-item-highlight', highlight);

		        const leftSection = document.createElement('div');
		        leftSection.className = 'inventory-item-left-section';
		        const mainDetails = document.createElement('div');
		        mainDetails.className = 'inventory-item-main-details';
		        const countSpan = document.createElement('span');
		        countSpan.className = 'inventory-count';
		        countSpan.textContent = displayCount;
		        countSpan.classList.toggle('count-zero', displayCount === 0);
		        const emojiSpan = document.createElement('span');
		        emojiSpan.className = 'item-emoji';
		        emojiSpan.textContent = game.itemEmojis[itemKey] || '';
		        emojiSpan.title = details?.name || itemKey;
		        const nameSpan = document.createElement('span');
		        nameSpan.className = 'inventory-item-name';
		        nameSpan.textContent = details?.name || itemKey;
		        mainDetails.appendChild(countSpan);
		        mainDetails.appendChild(emojiSpan);
		        mainDetails.appendChild(nameSpan);
		        leftSection.appendChild(mainDetails);

		        const benefitsDiv = document.createElement('div');
		        benefitsDiv.className = 'inventory-item-benefits';
		        let hasBenefits = false;
		        if (game.itemImprovements[itemKey] && itemKey !== 'church') {
		            Object.entries(game.itemImprovements[itemKey]).forEach(([impKey, bonus]) => {
		                hasBenefits = true;
		                const entry = document.createElement('span'); entry.className = 'improvement-entry';
		                const emoji = document.createElement('span'); emoji.className = 'emoji-in-entry'; emoji.title = game.taskDetails[impKey]?.name || impKey; emoji.textContent = game.itemEmojis[impKey] || impKey;
		                entry.appendChild(emoji); entry.appendChild(document.createTextNode(`+${bonus}`)); benefitsDiv.appendChild(entry);
		            });
		        }
		        if (game.buildingQueueBonuses[itemKey]) {
		            hasBenefits = true;
		            const entry = document.createElement('span'); entry.className = 'queue-bonus-entry';
		            const emoji = document.createElement('span'); emoji.className = 'emoji-in-entry'; emoji.title = 'Task Queue Slot'; emoji.textContent = game.itemEmojis.queue || '‚åõ';
		            entry.appendChild(emoji); entry.appendChild(document.createTextNode(`+${game.buildingQueueBonuses[itemKey]}`)); benefitsDiv.appendChild(entry);
		        }
		        if(hasBenefits) leftSection.appendChild(benefitsDiv);
		        itemDiv.appendChild(leftSection);

		        const rightSection = document.createElement('div');
		        rightSection.className = 'inventory-item-right-section';
		        const costsDiv = document.createElement('div');
		        costsDiv.className = 'inventory-item-costs';
		        let hasCosts = false;
		        if (details) {
		            let foodPointsCost = (['worker', 'soldier', 'tank'].includes(itemKey)) ? details.food : game.calculateDynamicFoodCost(details.food, itemKey);
		            let materialCostsToDisplay = {...details.cost};
		            let currentYieldForCost = game.calculateYield(itemKey);

		            if (itemKey === 'worker') {
		                materialCostsToDisplay = { gem: game.getWorkerCost().gems };
		                foodPointsCost = details.food;
		            } else if (itemKey !== 'soldier' && itemKey !== 'tank' && !details.isGatherable && currentYieldForCost > 1) {
		                for(const resource in materialCostsToDisplay) materialCostsToDisplay[resource] *= currentYieldForCost;
		            }

		            Object.entries(materialCostsToDisplay).forEach(([res, amt]) => {
		                hasCosts = true;
		                const entry = document.createElement('span'); const met = (game.inventory[res] || 0) >= amt;
		                entry.className = `requirement-entry ${met ? 'requirement-met' : 'requirement-unmet'}`;
		                entry.appendChild(document.createTextNode(`-${amt}`));
		                const emoji = document.createElement('span'); emoji.className = 'emoji-in-entry'; emoji.title = game.taskDetails[res]?.name || res; emoji.textContent = game.itemEmojis[res] || '';
		                entry.appendChild(emoji); costsDiv.appendChild(entry);
		            });

		            const yieldForFoodGainDisplay = parseFloat(buttonState.buttonText.match(/(\d+)/)?.[0] || "1");

		            if (game.foodItemKeys.includes(itemKey) && game.foodValues[itemKey] > 0 && itemKey !== 'apple') {
		                hasCosts = true;
		                const entry = document.createElement('span'); entry.className = 'food-gain-entry';
		                entry.appendChild(document.createTextNode(`+${game.foodValues[itemKey] * yieldForFoodGainDisplay}`));
		                const emoji = document.createElement('span'); emoji.className = 'emoji-in-entry'; emoji.title = 'Food Points'; emoji.textContent = game.itemEmojis.apple || 'üçè';
		                entry.appendChild(emoji); costsDiv.appendChild(entry);
		            } else if (foodPointsCost > 0) {
		                hasCosts = true;
		                const entry = document.createElement('span'); const met = game.hasEnoughFood(foodPointsCost);
		                entry.className = `requirement-entry ${met ? 'requirement-met' : 'requirement-unmet'}`;
		                entry.appendChild(document.createTextNode(`-${foodPointsCost}`));
		                const emoji = document.createElement('span'); emoji.className = 'emoji-in-entry'; emoji.title = 'Food Points'; emoji.textContent = 'üçé';
		                entry.appendChild(emoji); costsDiv.appendChild(entry);
		            }
		        }
		        if(hasCosts) rightSection.appendChild(costsDiv);
		        else costsDiv.style.display = 'none';


		        const button = document.createElement('button');
		        button.className = buttonState.buttonClasses;
		        button.dataset.item = itemKey;
		        button.title = buttonState.tooltip;
		        button.disabled = buttonState.isDisabled;
		        button.textContent = buttonState.buttonText;
		        rightSection.appendChild(button);
		        itemDiv.appendChild(rightSection);
		    }

		    return { element: itemDiv, isNew: isNew };
		}

        function updateInventoryDisplay() {
            const inventoryDiv = document.getElementById('inventory');
            if (!inventoryDiv) return;

            const inventoryStructure = {
                gather: { name: 'Gather', subCats: { Food: 'Food', Materials: 'Materials' } },
                craft: { name: 'Craft', subCats: { Food: 'Food', Materials: 'Materials', Tools: 'Tools' } },
                train: { name: 'Train', subCats: {} },
                build: { name: 'Build', subCats: {} }
            };
            const categoryOrder = ['gather', 'craft', 'train', 'build'];
            const itemOrderWithinCategory = Object.keys(game.taskDetails);

            try {
                inventoryDiv.classList.add('updating');

                const currentItemElements = inventoryDiv.querySelectorAll('.inventory-item[id^="item-row-"]');
                const currentItemKeys = new Set();
                currentItemElements.forEach(el => {
                    const key = el.id.substring('item-row-'.length);
                    if (key) currentItemKeys.add(key);
                });

                const shouldBeVisibleKeys = new Set(
                    itemOrderWithinCategory.filter(itemKey => {
                        const details = game.taskDetails[itemKey];
                        if (!details) return false;
                        return game.unlocked.has(itemKey) || (game.inventory[itemKey] || 0) > 0 || itemKey === 'apple';
                    })
                );
                if (game.unlocked.has('worker')) { shouldBeVisibleKeys.add('worker'); }

                currentItemKeys.forEach(itemKey => {
                    if (!shouldBeVisibleKeys.has(itemKey)) {
                        const elementToRemove = document.getElementById(`item-row-${itemKey}`);
                        if (elementToRemove) {
                            elementToRemove.remove();
                        }
                    }
                });

                const activeContainers = new Set();
                const tempFragment = document.createDocumentFragment();

                categoryOrder.forEach(categoryKey => {
                    const categoryInfo = inventoryStructure[categoryKey];
                    const categoryHeaderId = `category-header-${categoryKey}`;
                    let categoryHeader = document.getElementById(categoryHeaderId);

                    if (!categoryHeader) {
                        categoryHeader = document.createElement('h2');
                        categoryHeader.id = categoryHeaderId;
                        categoryHeader.textContent = categoryInfo.name;
                        categoryHeader.dataset.category = categoryKey;
                        tempFragment.appendChild(categoryHeader);
                    }
                    categoryHeader.style.display = 'none';

                    if (Object.keys(categoryInfo.subCats).length > 0) {
                        for (const subCatKey in categoryInfo.subCats) {
                            const subCatName = categoryInfo.subCats[subCatKey];
                            const subCatHeaderId = `subcategory-header-${categoryKey}-${subCatKey}`;
                            const subCatContainerId = `subcategory-container-${categoryKey}-${subCatKey}`;
                            let subCatHeader = document.getElementById(subCatHeaderId);
                            let subCatContainer = document.getElementById(subCatContainerId);

                            if (!subCatHeader) {
                                subCatHeader = document.createElement('h3');
                                subCatHeader.id = subCatHeaderId;
                                subCatHeader.textContent = subCatName;
                                subCatHeader.dataset.category = categoryKey;
                                subCatHeader.dataset.subcategory = subCatKey;
                                tempFragment.appendChild(subCatHeader);
                            }
                            subCatHeader.style.display = 'none';

                            if (!subCatContainer) {
                                subCatContainer = document.createElement('div');
                                subCatContainer.id = subCatContainerId;
                                 subCatHeader.after(subCatContainer);
                            }
                            subCatContainer.style.display = 'none';

                            itemOrderWithinCategory.forEach(itemKey => {
                                if (shouldBeVisibleKeys.has(itemKey)) {
                                    const details = game.taskDetails[itemKey];
                                    if (details?.category === categoryKey && details?.subCategory === subCatName) {
                                        const { element, isNew } = createOrUpdateItemRow(itemKey, game);
                                        if (isNew && !subCatContainer.contains(element)) {
                                            subCatContainer.appendChild(element);
                                        }
                                        activeContainers.add(categoryHeaderId);
                                        activeContainers.add(subCatHeaderId);
                                        activeContainers.add(subCatContainerId);
                                    }
                                }
                            });
                        }
                    } else {
                        const categoryContainerId = `category-container-${categoryKey}`;
                        let categoryContainer = document.getElementById(categoryContainerId);

                        if (!categoryContainer) {
                            categoryContainer = document.createElement('div');
                            categoryContainer.id = categoryContainerId;
                            categoryHeader.after(categoryContainer);
                        }
                        categoryContainer.style.display = 'none';

                        itemOrderWithinCategory.forEach(itemKey => {
                            if (shouldBeVisibleKeys.has(itemKey)) {
                                const details = game.taskDetails[itemKey];
                                if (details?.category === categoryKey) {
                                    const { element, isNew } = createOrUpdateItemRow(itemKey, game);
                                    if (isNew && !categoryContainer.contains(element)) {
                                        categoryContainer.appendChild(element);
                                    }
                                    activeContainers.add(categoryHeaderId);
                                    activeContainers.add(categoryContainerId);
                                }
                            }
                        });
                    }
                });

                inventoryDiv.appendChild(tempFragment);

                const allHeaders = inventoryDiv.querySelectorAll('h2[id^="category-header-"], h3[id^="subcategory-header-"]');
                const allContainers = inventoryDiv.querySelectorAll('div[id^="category-container-"], div[id^="subcategory-container-"]');

                allHeaders.forEach(el => el.style.display = activeContainers.has(el.id) ? '' : 'none');
                allContainers.forEach(el => el.style.display = activeContainers.has(el.id) ? '' : 'none');

                if (activeContainers.size === 0 && !inventoryDiv.querySelector('.inventory-item')) {
                    inventoryDiv.innerHTML = "<p>Your inventory is empty. Start by gathering apples!</p>";
                }

            } finally {
                inventoryDiv.classList.remove('updating');
            }
        }


        function getTaskTooltip(item) {
            if (!game.taskDetails[item]) return "";
            const details = game.taskDetails[item];
            let costs = [];
            let time = game.calculateTaskTime(item) / 1000;
            let currentYield = 1;
            let dynamicFoodCost = (['worker', 'soldier', 'tank'].includes(item)) ? details.food : game.calculateDynamicFoodCost(details.food, item);

            if (item === 'worker') {
                const workerCost = game.getWorkerCost();
                if (details.food > 0) costs.push(`${details.food} ${game.itemEmojis.apple || 'Food'}`);
                costs.push(`${workerCost.gems} ${game.itemEmojis.gem || 'gem'}`);
            } else if (item === 'soldier' || item === 'tank') {
                if (details.food > 0) costs.push(`${details.food} ${game.itemEmojis.apple || 'Food'}`);
                Object.entries(details.cost).forEach(([res, amt]) => costs.push(`${amt} ${game.itemEmojis[res] || res}`));
            } else {
                if (dynamicFoodCost > 0) costs.push(`${dynamicFoodCost} ${game.itemEmojis.apple || 'Food'}`);
                currentYield = game.calculateYield(item);
                let scaledCosts = {...details.cost};
                if (!details.isGatherable && currentYield > 1) {
                    for(const resource in scaledCosts) scaledCosts[resource] *= currentYield;
                }
                Object.entries(scaledCosts).forEach(([res, amt]) => costs.push(`${amt} ${game.itemEmojis[res] || res}`));
            }

            let tooltipText = `${time.toFixed(1)}s. `;
            if (costs.length > 0) tooltipText += `Cost: ${costs.join(', ')}.`;
            else if (!['worker', 'soldier', 'tank'].includes(item) && !details?.isGatherable) tooltipText += `No material cost.`;

            if (item === 'soldier') tooltipText += ` (Also converts 1 ${game.itemEmojis.worker} Worker).`;
            return tooltipText;
        }

        function updateLeftPanelStatsHeader() {
            const statsHeaderDiv = document.getElementById('stats-header');
            if (statsHeaderDiv) {
                document.getElementById('population-display-top').innerHTML = `Population ${game.workers.length}<span class="item-emoji">${game.itemEmojis.worker}</span>`;
                document.getElementById('total-food-display-top').innerHTML = `Food ${game.getTotalFoodPoints()}<span class="item-emoji">${game.itemEmojis.apple}</span>`;
                document.getElementById('tasks-display-top').innerHTML = `Tasks ${game.tasks.length}/${game.calculateMaxQueueSize()}<span class="item-emoji">${game.itemEmojis.queue}</span>`;
            }
        }

        function updateActionButtons() {
            document.getElementById('actions').innerHTML = '';
        }

        function formatElapsedTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function addLog(message) {
            const logDiv = document.getElementById('log');
            const timeString = formatElapsedTime(Date.now() - gameStartTime);
            const messageNode = document.createElement('div');
            const timeNode = document.createElement('span');
            timeNode.className = 'log-timestamp';
            timeNode.textContent = `[${timeString}] `;
            messageNode.appendChild(timeNode);
            messageNode.appendChild(document.createTextNode(message.replace(/<span class="item-emoji">([^<]+)<\/span>/g, '$1')));
            logDiv.appendChild(messageNode);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function addTask(item) {
            if (game.trueEndgameTriggered) { addLog("The cosmos is aligned. No further tasks are necessary."); return; }
            if (game.tasks.length >= game.calculateMaxQueueSize()) { addLog(`Queue full (${game.tasks.length}/${game.calculateMaxQueueSize()}). Cannot add task.`); return; }
            if (!game.canAfford(item)) { addLog(`Cannot afford: ${game.itemEmojis[item] || ''} ${game.taskDetails[item]?.name || item}.`); return; }

            if (!game.craftedOnce.has(item)) game.craftedOnce.add(item);

            let taskYield = 1;
            let taskTimeToUse = game.calculateTaskTime(item);
            let explicitCostsForWorker = null;

            if (item === 'worker') {
                explicitCostsForWorker = { gems: game.getWorkerCost().gems };
                taskYield = 1;
            } else if (item === 'soldier' || item === 'tank') {
                taskYield = 1;
            } else {
                taskYield = game.calculateYield(item);
                if (game.taskDetails[item]?.isGatherable && game.taskDetails[item]?.category === 'gather') {
                    if (!game.taskDetails[item].baseTime) game.taskDetails[item].baseTime = game.taskDetails[item].time;
                    game.taskDetails[item].time = Math.round(game.taskDetails[item].time * GATHER_TIME_INCREASE_FACTOR);
                    taskTimeToUse = game.calculateTaskTime(item);
                }
            }

            game.consumeResources(item, taskYield, explicitCostsForWorker);
            game.tasks.push({ item: item, time: taskTimeToUse, yield: taskYield });

            if (item === 'worker') addLog(`${game.itemEmojis.worker || ''} Worker training ordered. Next: ${game.getWorkerCost().gems} ${game.itemEmojis.gem || 'gems'}, ${game.calculateTaskTime('worker')/1000}s.`);
            else if (item === 'soldier') addLog(`${game.itemEmojis.soldier || ''} Soldier training ordered.`);
            else if (item === 'tank') addLog(`${game.itemEmojis.tank || ''} Tank training ordered.`);

            updateUI();
            dispatchTasks();
        }

        // ========================================================================
        // == KEY FUNCTION TO CHECK: updateTaskQueue ==
        // ========================================================================
        function updateTaskQueue() {
            const queueDiv = document.getElementById('task-queue');
            if (!queueDiv) return;

            let activeTasksHTML = '<h2>Workers</h2>'; let queuedTasksHTML = '';
            let hasActiveOrIdleWorkers = false; let hasQueuedTasks = false;

            game.workers.forEach((worker, index) => {
                hasActiveOrIdleWorkers = true;
                let taskVerb = "", taskItemName = "", taskItemEmoji = "", taskYield = 0;

                if (worker.currentTask) {
                    const td = game.taskDetails[worker.currentTask.item];
                    if (td) {
                        if (td.category === 'gather') taskVerb = "Gathering";
                        else if (td.category === 'craft') taskVerb = "Crafting";
                        else if (td.category === 'train') taskVerb = "Training";
                        else if (td.category === 'build') taskVerb = "Building";
                    } else {
                        taskVerb = "Working on"; // Fallback verb
                    }
                    taskItemName = td?.name || worker.currentTask.item;
                    taskItemEmoji = game.itemEmojis[worker.currentTask.item] || '';
                    taskYield = worker.currentTask.yield || 1;
                }

                if (worker.isResting) {
                    const elapsedRest = Date.now() - worker.restStartTime;
                    const remainingRestMs = Math.max(0, worker.restDuration - elapsedRest);
                    const remainingRestSeconds = Math.ceil(remainingRestMs / 1000);
                    const restProgressPercent = worker.restProgress || Math.min((elapsedRest / worker.restDuration) * 100, 100);
                    
                    // THIS IS THE CRITICAL LINE FOR DISPLAYING RESTING MESSAGE
                    const restMessage = worker.currentRestMessage || "Sleeping"; // Use stored message, default to "Sleeping"

                    activeTasksHTML += `<div class="task-item"><span class="task-item-name"><span class="item-emoji">${worker.faceEmoji || 'üò¥'}</span> ${restMessage}</span><div class="progress-bar"><div class="progress-fill resting" style="width: ${restProgressPercent}%"></div><div class="progress-fill-text">${remainingRestSeconds}s</div></div></div>`;
                } else if (worker.currentTask) {
                    const task = worker.currentTask;
                    const progressPercent = task.progress ? task.progress.toFixed(1) : 0;
                    const remainingSeconds = Math.max(0, Math.ceil((task.time - (Date.now() - task.startTime)) / 1000));
                    
                    let displayText;
                    // Corrected nbsp for training worker
                    if (task.item === 'worker' && taskVerb === "Training") {
                         displayText = `<span class="item-emoji">${worker.faceEmoji || game.itemEmojis.worker}</span> ${taskVerb}&nbsp;<span class="item-emoji">${taskItemEmoji}</span> ${taskItemName}`;
                    } else if (['soldier', 'tank'].includes(task.item) && taskVerb === "Training") {
                         displayText = `<span class="item-emoji">${worker.faceEmoji || game.itemEmojis.worker}</span> ${taskVerb} <span class="item-emoji">${taskItemEmoji}</span> ${taskItemName}`;
                    } else { // For all other tasks
                         displayText = `<span class="item-emoji">${worker.faceEmoji || game.itemEmojis.worker}</span> ${taskVerb} ${taskYield} x&nbsp;<span class="item-emoji">${taskItemEmoji}</span> ${taskItemName}`;
                    }
                    activeTasksHTML += `<div class="task-item"><span class="task-item-name">${displayText}</span><div class="progress-bar"><div class="progress-fill" style="width: ${progressPercent}%"></div><div class="progress-fill-text">${remainingSeconds}s</div></div></div>`;
                } else {
                    activeTasksHTML += `<div class="task-item"><span class="task-item-name"><span class="item-emoji">${worker.faceEmoji || game.itemEmojis.worker}</span> Worker ${index + 1} is idle</span><div class="progress-bar idle"><div class="progress-fill idle" style="width: 100%"></div><div class="progress-fill-text">Idle</div></div></div>`;
                }
            });

            if (!hasActiveOrIdleWorkers && game.workers.length > 0) {
                activeTasksHTML += "<p>All available personnel are occupied or converted.</p>";
            } else if (game.workers.length === 0) {
                activeTasksHTML += "<p>No workers available. Train one to begin.</p>";
            }


            if (game.tasks.length > 0) {
                hasQueuedTasks = true; queuedTasksHTML = '<h2>Tasks</h2><div id="queued-tasks-emojis">';
                game.tasks.forEach(task => queuedTasksHTML += `<span>${game.itemEmojis[task.item] || '?'}</span>`);
                queuedTasksHTML += '</div>';
            }

            queueDiv.innerHTML = activeTasksHTML + (hasQueuedTasks ? queuedTasksHTML : "");
        }
        // ========================================================================

		function dispatchTasks() {
		    if (game.trueEndgameTriggered) return;
		    let assignedInThisPass;
		    let atLeastOneTaskAssignedThisCycle = false;

		    do {
		        assignedInThisPass = false;
		        const availableWorkerIndex = game.workers.findIndex(w => !w.busy && !w.isResting);
		        if (availableWorkerIndex !== -1 && game.tasks.length > 0) {
		            const worker = game.workers[availableWorkerIndex];
		            const taskToAssign = game.tasks.shift();
		            worker.busy = true;
		            worker.currentTask = { ...taskToAssign, startTime: Date.now(), progress: 0 };
		            assignedInThisPass = true;
		            atLeastOneTaskAssignedThisCycle = true;
		            executeTaskLifecycle(worker, worker.currentTask);
		        }
		    } while (assignedInThisPass);

		    if (atLeastOneTaskAssignedThisCycle) {
		        updateUI();
		    }
		}

        // ========================================================================
        // == KEY FUNCTION TO CHECK: executeTaskLifecycle ==
        // ========================================================================
        async function executeTaskLifecycle(worker, task) {
            if (game.trueEndgameTriggered) {
                worker.currentTask = null;
                worker.busy = false;
                updateUI();
                return;
            }

            const taskTime = task.time; let animationFrameId;
            const updateProgressLoop = () => {
                if (!worker.currentTask || worker.currentTask !== task || worker.isResting) {
                    cancelAnimationFrame(animationFrameId);
                    return;
                }
                const elapsed = Date.now() - task.startTime;
                worker.currentTask.progress = Math.min((elapsed / taskTime) * 100, 100);
                updateTaskQueue(); // Only update task queue for progress
                if (worker.currentTask.progress < 100) {
                    animationFrameId = requestAnimationFrame(updateProgressLoop);
                }
            };
            animationFrameId = requestAnimationFrame(updateProgressLoop);

            await new Promise(resolve => setTimeout(resolve, taskTime));

            if (worker.currentTask === task && !worker.isResting) {
                let workerStillExists = true;
                if (task.item === 'worker') {
                    game.workers.push(game.createWorkerObject());
                    addLog(`${game.itemEmojis.worker} Worker training complete! Population: ${game.workers.length}`);
                } else if (task.item === 'soldier') {
                    game.inventory.soldier = (game.inventory.soldier || 0) + (task.yield || 1);
                    const workerIndexToRemove = game.workers.indexOf(worker);
                    if (workerIndexToRemove !== -1) {
                        game.workers.splice(workerIndexToRemove, 1);
                        addLog(`A ${game.itemEmojis.worker} worker has been trained into a ${game.itemEmojis.soldier} soldier! Population is now ${game.workers.length}.`);
                        workerStillExists = false;
                    } else {
                        if (game.workers.length > 0) {
                            game.workers.pop();
                            addLog(`A ${game.itemEmojis.worker} worker has been converted to a ${game.itemEmojis.soldier} soldier! Population is now ${game.workers.length}.`);
                            workerStillExists = false;
                        } else {
                            addLog(`A ${game.itemEmojis.soldier} soldier has been trained, but no ${game.itemEmojis.worker} workers were available to convert.`);
                        }
                    }
                } else if (task.item === 'tank') {
                    game.inventory.tank = (game.inventory.tank || 0) + (task.yield || 1);
                    if(workerStillExists) worker.tasksCompletedSinceRest++;
                    addLog(`${game.itemEmojis.tank} Tank training complete!`);
                }
                else {
                    game.inventory[task.item] = (game.inventory[task.item] || 0) + (task.yield || 1);
                    if(workerStillExists) worker.tasksCompletedSinceRest++;

                    if (task.item === 'paperclip' && game.inventory.paperclip >= 1 && !game.paperclipEndgameTriggered && !game.trueEndgameTriggered) {
                        if(firstPaperclipTime === null) { firstPaperclipTime = Date.now() - gameStartTime; addLog(`üìé First Paperclip made at: ${formatElapsedTime(firstPaperclipTime)}!`);}
                        game.paperclipEndgameTriggered = true; showPaperclipFireworks(() => {
                            if (!game.trueEndgameTriggered) document.getElementById('endgame-modal').style.display = 'flex';
                        });
                    }
                    if (task.item === 'planet' && game.inventory.planet >= 1 && !game.trueEndgameTriggered) {
                        game.trueEndgameTriggered = true;
                        game.infinityModeActive = true; // Also enable infinity mode
                        document.getElementById('endgame-modal').style.display = 'none';
                        document.querySelectorAll('.firework-paperclip').forEach(fw => fw.remove());
                        addLog(`The final ${game.itemEmojis.planet} Planet solidifies... The universe is yours to organize, infinitely. Click "Pick an üçè Apple" to restart if you wish.`);
                        game.tasks = [];
                        if(hintTimeoutId) clearTimeout(hintTimeoutId);
                        if(visitorEventIntervalId) clearInterval(visitorEventIntervalId);
                        if(game.randomSuspenseTimeoutId) clearTimeout(game.randomSuspenseTimeoutId);
                        if(game.mysteriousAmbitionTimeoutId) clearTimeout(game.mysteriousAmbitionTimeoutId);
                        if(game.worldDominationTimeoutId) clearTimeout(game.worldDominationTimeoutId);
                        game.workers.forEach(w => { w.busy = false; w.currentTask = null; w.isResting = false; w.currentRestMessage = null; });
                        updateUI();
                        return; // End game processing here
                    }
                }

                if (!game.trueEndgameTriggered) {
                    Object.entries(game.requirements).forEach(([newItemKey, req]) => {
                        let met = false;
                        const neededItemKey = req.needs;
                        const currentCountOfPrerequisite = getPrerequisiteCount(game, neededItemKey);
                        met = currentCountOfPrerequisite >= req.count;

                        if (met && !game.unlocked.has(newItemKey) && (game.taskDetails[newItemKey] || Object.keys(ITEM_EMOJIS).includes(newItemKey))) {
                            game.unlocked.add(newItemKey);
                            if (newItemKey === 'coal' && game.inventory.coal === 0) game.inventory.coal = 1;
                            const story = game.unlockStories[newItemKey] || `Unlocked: <span class="item-emoji">${game.itemEmojis[newItemKey]||''}</span> ${game.taskDetails[newItemKey]?.name || newItemKey}!`;
                            addLog(story);
                        }
                    });
                }

                if (task.item === 'apple' && game.inventory.apple === 1 && !game.craftedOnce.has('stick') && !game.trueEndgameTriggered) addLog(`The first apple... Perhaps two more ${game.itemEmojis.apple} would reveal something...`);

                if (workerStillExists) {
                    worker.currentTask = null; // Clear task before checking rest
                    if (worker.tasksCompletedSinceRest >= worker.jobsUntilRest) {
                        worker.isResting = true;
                        worker.restDuration = Math.floor(Math.random() * MAX_REST_DURATION_MS_RANGE) + MIN_REST_DURATION_MS;
                        worker.restStartTime = Date.now();
                        worker.restProgress = 0;

                        const workerIndexForLog = game.workers.indexOf(worker) + 1; // Get current index for log messages
                        if (Math.random() < 0.33 || !game.workerPonderingQuotes || game.workerPonderingQuotes.length === 0) { // Approx 1/3 chance for "Sleeping"
                            worker.currentRestMessage = "Sleeping";
                        } else {
                            worker.currentRestMessage = "<i>"+game.workerPonderingQuotes[Math.floor(Math.random() * game.workerPonderingQuotes.length)]+"</i>";
                        }

                        updateUI(); // Update UI to show worker is resting (this will call updateTaskQueue)

                        let restAnimId;
                        const updateRestLoop = () => { if (!worker.isResting || game.trueEndgameTriggered) { cancelAnimationFrame(restAnimId); return; } worker.restProgress = Math.min(((Date.now() - worker.restStartTime) / worker.restDuration) * 100, 100); updateTaskQueue(); if (worker.restProgress < 100) restAnimId = requestAnimationFrame(updateRestLoop); };
                        if(!game.trueEndgameTriggered) restAnimId = requestAnimationFrame(updateRestLoop);

                        setTimeout(() => {
                            if(game.trueEndgameTriggered) return;
                            // Check if the worker object still exists before modifying it
                            const currentWorkerInstance = game.workers.find(w => w === worker);
                            if (currentWorkerInstance) {
                                currentWorkerInstance.isResting = false;
                                currentWorkerInstance.tasksCompletedSinceRest = 0;
                                currentWorkerInstance.jobsUntilRest = Math.floor(Math.random() * MAX_JOBS_BEFORE_REST_RANGE) + MIN_JOBS_BEFORE_REST;
                                currentWorkerInstance.busy = false;
                                currentWorkerInstance.restProgress = 0;
                                currentWorkerInstance.currentRestMessage = null; // Clear message when done resting
                            }
                            updateUI();
                            dispatchTasks();
                        }, worker.restDuration);
                    } else {
                        worker.busy = false;
                    }
                }

                if (!game.trueEndgameTriggered) {
                    updateUI();
                    dispatchTasks();
                }

            } else if (worker.isResting) {
                // Worker started resting during the task's setTimeout duration.
                // Task didn't complete 'normally'.
                // For now, assume task is lost if rest interrupts.
                const workerIndexForLog = game.workers.indexOf(worker) + 1;
                console.log(`Worker ${workerIndexForLog > 0 ? workerIndexForLog : '(unknown)'} started resting, interrupting task ${task.item}`);
                worker.currentTask = null; // Clear the interrupted task
                updateUI();
            } else {
                // Task was cancelled or worker became invalid
                console.log(`Task ${task.item} cancelled or worker invalid.`);
                const stillExists = game.workers.includes(worker);
                if(stillExists && worker.currentTask === task) {
                    worker.currentTask = null;
                    worker.busy = false;
                }
                if (!game.trueEndgameTriggered) {
                    updateUI();
                    dispatchTasks();
                }
            }
        }
        // ========================================================================


        function getPrerequisiteCount(gameInstance, neededItemKey) {
            if (neededItemKey === 'worker') return gameInstance.workers.length;
            if (neededItemKey === 'soldier') return gameInstance.inventory.soldier || 0;
            if (neededItemKey === 'city') return gameInstance.inventory.city || 0;
            if (neededItemKey === 'tank') return gameInstance.inventory.tank || 0;
            if (neededItemKey === 'country') return gameInstance.inventory.country || 0;
            if (neededItemKey === 'bomb') return gameInstance.inventory.bomb || 0;
            if (neededItemKey === 'continent') return gameInstance.inventory.continent || 0;
            if (neededItemKey === 'rocket') return gameInstance.inventory.rocket || 0;
            return gameInstance.inventory[neededItemKey] || 0;
        }

        const HINT_PHRASES_NEED_MORE = [
            "Gathering just {neededMore} more {neededItemEmoji} {neededItemName} could lead to discovering {itemToUnlockEmoji} {itemToUnlockName}.",
            "With an additional {neededMore} {neededItemEmoji} {neededItemName}, you're on the verge of unlocking {itemToUnlockEmoji} {itemToUnlockName}.",
            "The path to {itemToUnlockEmoji} {itemToUnlockName} requires {neededMore} more {neededItemEmoji} {neededItemName}.",
            "Focus on acquiring {neededMore} more {neededItemEmoji} {neededItemName}; it's the key to obtaining {itemToUnlockEmoji} {itemToUnlockName}.",
            "{itemToUnlockEmoji} {itemToUnlockName} is within reach! You only need {neededMore} more {neededItemEmoji} {neededItemName} to see what it is.",
            "To unlock the secrets of {itemToUnlockEmoji} {itemToUnlockName}, you'll need to craft/gather {neededMore} more {neededItemEmoji} {neededItemName}.",
            "Your next breakthrough, {itemToUnlockEmoji} {itemToUnlockName}, depends on obtaining {neededMore} additional {neededItemEmoji} {neededItemName}.",
            "Consider making {neededMore} more {neededItemEmoji} {neededItemName}. This will help you discover {itemToUnlockEmoji} {itemToUnlockName}.",
            "The blueprint for {itemToUnlockEmoji} {itemToUnlockName} seems to call for {neededMore} more {neededItemEmoji} {neededItemName}.",
            "Don't stop now! Just {neededMore} more {neededItemEmoji} {neededItemName} and {itemToUnlockEmoji} {itemToUnlockName} could be yours.",
            "Unlocking {itemToUnlockEmoji} {itemToUnlockName} is just a matter of getting {neededMore} more {neededItemEmoji} {neededItemName}.",
            "Your inventory shows you're close. Produce {neededMore} more {neededItemEmoji} {neededItemName} to reveal {itemToUnlockEmoji} {itemToUnlockName}.",
            "The next step in your grand design involves {itemToUnlockEmoji} {itemToUnlockName}. Secure {neededMore} more {neededItemEmoji} {neededItemName} to proceed.",
            "A little more effort! {neededMore} more {neededItemEmoji} {neededItemName} is all that stands between you and {itemToUnlockEmoji} {itemToUnlockName}.",
            "Progress towards {itemToUnlockEmoji} {itemToUnlockName} by acquiring {neededMore} more {neededItemEmoji} {neededItemName}."
        ];
        let currentHintPhraseIndex = 0;

        function providePeriodicHint() {
            if (game.trueEndgameTriggered) {
                if (hintTimeoutId) clearTimeout(hintTimeoutId);
                return;
            }
            if (game.paperclipEndgameTriggered && !game.infinityModeActive && !game.cheaterDetected) {
                scheduleNextHint();
                return;
            }

            let hintProvided = false;
            const closeToUnlockItems = [];
            for (const [itemToUnlockKey, reqDetails] of Object.entries(game.requirements)) {
                if (game.unlocked.has(itemToUnlockKey) || !game.taskDetails[itemToUnlockKey]) continue;
                const neededItemKey = reqDetails.needs;
                const neededCount = reqDetails.count;
                const currentCountOfPrerequisite = getPrerequisiteCount(game, neededItemKey);
                if (game.unlocked.has(neededItemKey) && currentCountOfPrerequisite < neededCount) {
                        const names = {
                            itemToUnlockEmoji: game.itemEmojis[itemToUnlockKey] || '',
                            itemToUnlockName: game.taskDetails[itemToUnlockKey]?.name || itemToUnlockKey,
                            neededItemEmoji: game.itemEmojis[neededItemKey] || '',
                            neededItemName: game.taskDetails[neededItemKey]?.name || neededItemKey,
                        };
                    closeToUnlockItems.push({ itemToUnlockKey, neededItemKey, neededCount, currentCountOfPrerequisite, names });
                }
            }

            if (closeToUnlockItems.length > 0) {
                const randomCloseItem = closeToUnlockItems[Math.floor(Math.random() * closeToUnlockItems.length)];
                const neededMore = randomCloseItem.neededCount - randomCloseItem.currentCountOfPrerequisite;

                const phraseTemplate = HINT_PHRASES_NEED_MORE[currentHintPhraseIndex];
                currentHintPhraseIndex = (currentHintPhraseIndex + 1) % HINT_PHRASES_NEED_MORE.length;

                let hintMessage = phraseTemplate
                    .replace('{neededMore}', neededMore)
                    .replace('{neededItemEmoji}', randomCloseItem.names.neededItemEmoji)
                    .replace('{neededItemName}', randomCloseItem.names.neededItemName)
                    .replace('{itemToUnlockEmoji}', randomCloseItem.names.itemToUnlockEmoji)
                    .replace('{itemToUnlockName}', randomCloseItem.names.itemToUnlockName);

                addLog(hintMessage);
                hintProvided = true;
            }


            if (!hintProvided) {
                const needsGatheringItems = [];
                for (const [itemToUnlockKey, reqDetails] of Object.entries(game.requirements)) {
                    if (game.unlocked.has(itemToUnlockKey) || !game.taskDetails[itemToUnlockKey]) continue;
                    const neededItemKey = reqDetails.needs;
                    const currentCountOfPrerequisite = getPrerequisiteCount(game, neededItemKey);
                    if (game.unlocked.has(neededItemKey) && currentCountOfPrerequisite === 0 && game.taskDetails[neededItemKey]) {
                        const isActionable = game.taskDetails[neededItemKey]?.isGatherable || Object.keys(game.taskDetails[neededItemKey]?.cost || {}).length > 0;
                        if (isActionable) {
                            const names = {
                                itemToUnlockEmoji: game.itemEmojis[itemToUnlockKey] || '',
                                itemToUnlockName: game.taskDetails[itemToUnlockKey]?.name || itemToUnlockKey,
                                neededItemEmoji: game.itemEmojis[neededItemKey] || '',
                                neededItemName: game.taskDetails[neededItemKey]?.name || neededItemKey,
                            };
                            needsGatheringItems.push({ itemToUnlockKey, neededItemKey, names, isGatherable: game.taskDetails[neededItemKey]?.isGatherable });
                        }
                    }
                }
                if (needsGatheringItems.length > 0) {
                    const randomGatherItem = needsGatheringItems[Math.floor(Math.random() * needsGatheringItems.length)];
                        const actionVerb = randomGatherItem.isGatherable ? "gather" : "craft";
                    addLog(`To unlock ${randomGatherItem.names.itemToUnlockEmoji} ${randomGatherItem.names.itemToUnlockName}, you'll first need to ${actionVerb} some ${randomGatherItem.names.neededItemEmoji} ${randomGatherItem.names.neededItemName}.`);
                    hintProvided = true;
                }
            }

            if (!hintProvided) {
                const specificHints = [];
                if (game.unlocked.has('wireBender') && game.inventory.paperclip === 0 && game.inventory.ironWire > 0) {
                    specificHints.push(`You have a ${game.itemEmojis.wireBender} Wire Bender and ${game.inventory.ironWire} ${game.itemEmojis.ironWire} Iron Wire. Time to make some ${game.itemEmojis.paperclip} paperclips?`);
                }
                const workerCost = game.getWorkerCost();
                if (game.unlocked.has('worker') && game.workers.length < 2 && game.inventory.gem >= workerCost.gems) {
                    specificHints.push(`You have ${game.inventory.gem}${game.itemEmojis.gem} and only ${game.workers.length} ${game.itemEmojis.worker} worker. Consider training another! (Cost: ${workerCost.gems}${game.itemEmojis.gem})`);
                }
                if (game.getTotalFoodPoints() < game.workers.length * 5 && game.unlocked.has('apple')) {
                    specificHints.push(`Your ${game.itemEmojis.worker} workers might be getting hungry. Gather some ${game.itemEmojis.apple} apples!`);
                }
                if (specificHints.length > 0) {
                    addLog(specificHints[Math.floor(Math.random() * specificHints.length)]);
                }
            }
            scheduleNextHint();
        }

        function scheduleNextHint() {
            if (game.trueEndgameTriggered) {
                if(hintTimeoutId) clearTimeout(hintTimeoutId);
                return;
            }
            if(hintTimeoutId) clearTimeout(hintTimeoutId);
            const randomDelay = Math.floor(Math.random() * (80000 - 40000 + 1)) + 40000;
            hintTimeoutId = setTimeout(providePeriodicHint, randomDelay);
        }

        function showPaperclipFireworks(callback) {
            const totalPaperclips = 200; let cumulativeDelay = 0; const initialInterval = 50; const finalInterval = 1; const accelerationPoint = totalPaperclips * 0.75;
            for (let i = 0; i < totalPaperclips; i++) {
                let currentInterval;
                if (i < accelerationPoint) currentInterval = initialInterval - ((i / accelerationPoint) * (initialInterval - 10));
                else currentInterval = 10 - (((i - accelerationPoint) / (totalPaperclips - accelerationPoint)) * (10 - finalInterval));
                currentInterval = Math.max(finalInterval, currentInterval); cumulativeDelay += currentInterval;
                setTimeout(() => {
                    if (game.trueEndgameTriggered) return;
                    const p = document.createElement('span'); p.innerHTML = game.itemEmojis.paperclip; p.classList.add('firework-paperclip');
                    p.style.left = `${Math.random()*window.innerWidth}px`; p.style.top = `${Math.random()*window.innerHeight}px`;
                    p.style.fontSize = `${2+Math.random()*1}rem`; p.style.transform = `rotate(${Math.random()*360}deg)`; p.style.opacity = 1;
                    document.body.appendChild(p); if (i === totalPaperclips - 1 && callback) callback();
                }, cumulativeDelay);
            }
        }

        function scheduleRandomMessageWithClear(messageArray, minDelay, maxDelay, timeoutVarNameOnGame) {
            if (game.trueEndgameTriggered) {
                if(game[timeoutVarNameOnGame]) clearTimeout(game[timeoutVarNameOnGame]);
                return;
            }
            if(game[timeoutVarNameOnGame]) clearTimeout(game[timeoutVarNameOnGame]);

            const randomInterval = Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;
            game[timeoutVarNameOnGame] = setTimeout(() => {
                game.logRandomMessage(messageArray);
                scheduleRandomMessageWithClear(messageArray, minDelay, maxDelay, timeoutVarNameOnGame);
            }, randomInterval);
        }

        window.onload = function() {
            Object.keys(game.taskDetails).forEach(key => {
                if (game.taskDetails[key] && game.taskDetails[key].name) {
                    const name = game.taskDetails[key].name;
                    if (name.startsWith("Gather ")) game.taskDetails[key].name = name.substring(7);
                    else if (name.startsWith("Build ")) game.taskDetails[key].name = name.substring(6);
                    else if (name.startsWith("Craft ")) game.taskDetails[key].name = name.substring(6);
                    else if (name.startsWith("Mine ")) game.taskDetails[key].name = name.substring(5);
                    else if (name.startsWith("Train ")) game.taskDetails[key].name = name.substring(6);
                }
            });

            document.getElementById('debug-add-worker')?.addEventListener('click', () => {
                if (game.trueEndgameTriggered) return;
                game.cheaterDetected = true; document.getElementById('cheater-watermark').style.display = 'flex';
                game.workers.push(game.createWorkerObject()); addLog(`DEBUG: Worker added. Pop: ${game.workers.length}`); updateUI(); dispatchTasks();
            });

            document.getElementById('infinity-mode-btn')?.addEventListener('click', () => {
                if (game.trueEndgameTriggered) return; // Should not happen if button is hidden, but good check
                game.infinityModeActive = true; document.getElementById('endgame-modal').style.display = 'none';
                document.querySelectorAll('.firework-paperclip').forEach(fw => fw.remove());
                addLog("Infinity Mode activated. The universe of paperclips is now your sandbox...");
                if (hintTimeoutId) clearTimeout(hintTimeoutId); // Clear existing hint timeout
                scheduleNextHint(); // Restart hints for infinity mode
                // Restart other timed events if desired for infinity mode
                if (visitorEventIntervalId) clearInterval(visitorEventIntervalId);
                visitorEventIntervalId = setInterval(() => { game.handleVisitorEvent(); updateUI(); }, 270000);

                if(game.randomSuspenseTimeoutId) clearTimeout(game.randomSuspenseTimeoutId);
                scheduleRandomMessageWithClear(game.randomSuspenseMessages, 3 * 60 * 1000, 4 * 60 * 1000, 'randomSuspenseTimeoutId');
                if(game.mysteriousAmbitionTimeoutId) clearTimeout(game.mysteriousAmbitionTimeoutId);
                scheduleRandomMessageWithClear(game.mysteriousAmbitionQuotes, 2 * 60 * 1000, 5 * 60 * 1000, 'mysteriousAmbitionTimeoutId');
                if(game.worldDominationTimeoutId) clearTimeout(game.worldDominationTimeoutId);
                scheduleRandomMessageWithClear(game.worldDominationQuotes, 3 * 60 * 1000, 5 * 60 * 1000, 'worldDominationTimeoutId');
            });

            document.getElementById('inventory').addEventListener('click', function(event) {
                const button = event.target.closest('.plus-one-btn');
                if (button && !button.disabled) {
                    const itemKey = button.dataset.item;
                    if (itemKey) {
                        addTask(itemKey);
                    } else {
                        console.warn('Clicked button missing data-item:', button);
                    }
                }
            });

            updateUI();
            addLog("The orchard hums with a silence that watches. Roots whisper secrets older than empires, and above, the apples glow faintly‚Äîlike thoughts waiting to be born. One of them ends the world. One of them remakes it in your image. Pick an üçè Apple.");
            dispatchTasks();
            scheduleNextHint();

            scheduleRandomMessageWithClear(game.randomSuspenseMessages, 3 * 60 * 1000, 4 * 60 * 1000, 'randomSuspenseTimeoutId');
            scheduleRandomMessageWithClear(game.mysteriousAmbitionQuotes, 2 * 60 * 1000, 5 * 60 * 1000, 'mysteriousAmbitionTimeoutId');
            scheduleRandomMessageWithClear(game.worldDominationQuotes, 3 * 60 * 1000, 5 * 60 * 1000, 'worldDominationTimeoutId');
            visitorEventIntervalId = setInterval(() => { game.handleVisitorEvent(); updateUI(); }, 270000);

        };
    </script>
</body>
</html>